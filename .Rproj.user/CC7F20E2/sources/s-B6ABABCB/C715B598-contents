---
title: Notebook for  Data Analyses of Chinese Samples in Psychological Subjects [Stage
  1 RR]
author: "Lei Yue (NNU, CCNU); Hu Chuan-Peng (NNU; hcp4715@hotmail.com)"
output:
  html_document:
    df_print: paged
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook for data analyses in the protocol of a meta research which aims at surveying the sample characteristics of Chinese sample in Psychological research. 

In this notebook, we will use data from PSA 001 project [Jones et al., 2021, *Nature Human Behavior*](https://doi.org/10.1038/s41562-020-01007-2) as an example to exemplify the analysis we are going to use in our first projects

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

First, load libraries.

```{r Initialization}
library(tidyverse)
library(ggridges)
library(openxlsx)
library(ggh4x)
library(stringr)
library(patchwork)
rm(list = ls())
```

Second, load the data and carry out initial preprocessing. 
```{r Loading data}

load("df_chinese_subj_rr_stage1.RData")

# Load regions code
# df_regionCode <- read.xlsx("Chin_Subj_F4(5)_region.xlsx")
# save(df_census6, df_CFPS2018, df_PSA001, df_regionCode, file = "df_chinese_subj_rr_stage1.RData")

# check data 
str(df_PSA001) # have an overview of the data
str(df_CFPS2018)
str(df_census6)
str(df_regionCode)
```

## Testing the 2nd hypothesis

Here we will test whether the sex ratio and age distribution from psychological studies are similar to that of the census data. As a comparison, we also compared that data from sociology, CFPS 2018, to the census data too. 

### Sex distribution

```{r H2 sex}
df_PSA001_sex <- df_PSA001 %>%
  dplyr::count(Sex) %>%
  dplyr::mutate(Proportion = round(n / sum(n), 2) * 100,
                Site = "PSA001",
                Sex = ifelse(Sex == "f", 'female', 'male' )) %>%
  dplyr::select(Site, Sex, Proportion)

df_census6_sex <- df_census6 %>%
  dplyr::select(c(6,7)) %>%        # select columns
  dplyr::slice(c(5)) %>%
  dplyr::rename(male=1, 
                female=2) %>%
  dplyr::mutate(Site = "Census6") %>%
  tidyr::pivot_longer(c(male, female), 
                      names_to = "Sex",
                      values_to = "Proportion") %>%
  dplyr::mutate(Proportion = round(as.numeric(Proportion), 0))


df_CFPS2018_sex <- df_CFPS2018 %>%
  dplyr::rename(Sex = QA002) %>%
  dplyr::count(Sex) %>%
  dplyr::filter(!is.na(Sex)) %>%
  dplyr::mutate(Proportion = round(n / sum(n), 2) * 100,
                Site = "CFPS2018",
                Sex = ifelse(Sex == 1, "male", "female")) %>%
  dplyr::select(Site, Sex, Proportion)

df_sex_ratio <- rbind(df_census6_sex, df_CFPS2018_sex, df_PSA001_sex)

### write the csv for JASP
df_sex_ratio_jasp <- df_sex_ratio %>%
  tidyr::pivot_wider(names_from = Site,
                     values_from = Proportion)
write.csv(df_sex_ratio_jasp, "df_fig3a.csv", row.names = F)

fig3a <- ggplot(df_sex_ratio, aes(Site, Proportion,fill=Sex)) +
  geom_col() +
  theme_classic()+
  xlab("Data sources") +
  theme(legend.position = "bottom",
        legend.key.size = unit(20,"pt"),
        legend.box.spacing = unit(4,"pt"),
        legend.title = element_blank(),
        axis.title = element_text(size = 16, family = "serif"),
        legend.text = element_text(size = 16, family = "serif"),
        axis.text = element_text(size =16, family = "serif"))

# fig3a  
```

### Age distribution

Here we will compare the age distribution of samples from psychological studies (PSA 001 as the example) and the Census data.

```{r H2 ageBins}
#  <- PSA_Jones_CN
df_PSA001_Age <- df_PSA001 %>%
  dplyr::filter(!is.na(Age)) %>%
  dplyr::mutate(ageBins_pyr = cut(Age, 
                                   breaks=c(-Inf, 5, 10, 15, 20, 25, 30, 35, 40, 45,
                                            50, 55,60,65,70, 75,80,85,90,95, Inf), 
                            labels=c("0~4","5~9","10~14", "15~19", "20~24", "25~29", "30~34", "35~39", "40~44",
                                     "45~49","50~54","55~59","60~64","65~69","70~74", "75~79",
                                     "80~84","85~89", "90~94",">=95"))) %>%
  dplyr::count(ageBins_pyr, Sex) %>%
  dplyr::mutate(Proportion = round(n / sum(n), 4) * 100,
                Site = "CFPS2018",
                Sex = ifelse(Sex == "f", "male_PSA", "female_PSA")) 


df_census6_age94 <- df_census6 %>%
  dplyr::select(c(1,6,7)) %>%        # select columns
  dplyr::slice(c(6,12,18,24,30,36,42,   # select rows
                 48,54,60,66,72,78,84,
                 90,96,102,108,114)) %>%
  dplyr::rename(ageBins=1,
                male=2,
                female=3) %>%
  dplyr::mutate(ageBins = c("0~4","5~9","10~14", "15~19", "20~24", "25~29", "30~34", "35~39", "40~44",
                                     "45~49","50~54","55~59","60~64","65~69","70~74", "75~79",
                                     "80~84","85~89", "90~94"))

###Combining the data of 95 years old and above and controlling the number of the decimal places
df_census6_age95 <- data.frame(ageBins = c(">=95"),
                            male = round((117716 + 8852)/1332810869*100, 2),
                            female = round((252263 + 27082)/1332810869*100, 2))

df_census6_age <- rbind(df_census6_age94, df_census6_age95) %>%
  dplyr::mutate(ageBins = factor(ageBins, levels = c("0~4","5~9","10~14", "15~19", "20~24", "25~29", "30~34", 
                                                     "35~39", "40~44","45~49","50~54","55~59","60~64","65~69",
                                                     "70~74", "75~79", "80~84","85~89", "90~94",">=95"))) %>%
  tidyr::pivot_longer(-ageBins, names_to = "Sex", values_to = "Proportion") %>%
  dplyr::mutate(Proportion=as.numeric(Proportion))
  

###Plotting
fig3b <- ggplot(data= df_census6_age, aes(x=ageBins, y=ifelse(Sex=="male", -Proportion, Proportion), fill=Sex)) +
  geom_col(alpha=0.5, width = 1) +
  geom_line(data = df_PSA001_Age, aes(x=ageBins_pyr,
                                      y = ifelse(Sex == "male_PSA", -Proportion/2.5, Proportion/2.5),
                                      group=Sex,color="PSA001"), size=1, inherit.aes = FALSE) +
  scale_y_continuous(limits = c(-15,15),sec.axis = sec_axis(~.*2.5, name = "Proportion (PSA001)")) +
  coord_flip() +
  labs(y="Proportion (census data)", x = "Age bins", color=NULL)+
  annotate("text",label= "italic(Male)",x=19,y=-2,parse=TRUE,size=8, family = "serif") +
  annotate("text",label= "italic(Female)",x=19,y=3,parse=TRUE,size=8,family = "serif") +
  scale_color_manual(values = c("red","blue"))+
  theme_classic()+
  theme(panel.border =element_rect(fill=NA,color="black"),
        legend.position ="bottom",
        legend.box.spacing = unit(2,"pt"),
        legend.text = element_text(size = 16, family = "serif"),
        legend.title = element_blank(),
        axis.title = element_text(size = 16,family = "serif"),
        axis.text = element_text(size = 16,family = "serif"))

fig3 <- fig3a + fig3b +  plot_annotation(tag_levels = 'A')
ggsave("fig3.pdf", fig3, device = "pdf", width=16, height = 9)

fig3
```

## Test H3
Third, select data for plotting.
```{r preproc data}
### Get countries with n >=30
PSA001_valid_countries <-  df_PSA001 %>%
  dplyr::group_by(Countries) %>%
  dplyr::summarise(n = n()) %>%
  dplyr::ungroup() %>%
  dplyr::filter(n >=30 & !is.na(Countries)) %>%
  dplyr::pull(Countries)

### remove data without sex info
df_PSA001_valid_sex <-  df_PSA001 %>% 
  dplyr::filter(Countries %in% PSA001_valid_countries) %>%
  dplyr::mutate(Sex = ifelse(Sex == "no" | Sex == "na", NA, Sex))


df_PSA001_valid_merge <- merge(df_PSA001_valid_sex, df_regionCode, by.x = "Countries", by.y = "country_iso2")

df_PSA001_valid_merge_sex_ratio <- df_PSA001_valid_merge %>%
  dplyr::filter(!is.na(Sex)) %>%
  dplyr::count(weird, Countries, Sex) %>%
  dplyr::group_by(weird, Countries) %>%
  dplyr::mutate(Proportion = round(n / sum(n), 2)) %>%
  dplyr::arrange(Sex, Proportion) %>%
  dplyr::ungroup()

countries_order_sex <- df_PSA001_valid_merge_sex_ratio %>%
  dplyr::filter(Sex == "f") %>%
  dplyr::pull(Countries)

df_PSA001_valid_merge_sex_ratio_sored <- df_PSA001_valid_merge_sex_ratio %>%
  dplyr::mutate(Countries = factor(Countries, levels = countries_order_sex))

df_PSA001_valid_merge_sex_ratio_sored %>%
  dplyr::mutate(Proportion = Proportion * 100) %>%
  write.csv(., "PSA001_sex_ratio_all.csv", row.names = F)

df_PSA001_valid_merge_sex_ratio_sored_wide <- df_PSA001_valid_merge_sex_ratio_sored %>%
  dplyr::select(-c(weird,n)) %>%
  dplyr::mutate(Proportion = Proportion * 100)  %>%
  tidyr::pivot_wider(names_from = "Countries", values_from = "Proportion")

df_PSA001_valid_merge_sex_ratio_sored_wide %>%
  write.csv(., "Fig4a_sex_wide.csv", row.names = F)
```

Plot figure 4a, 
```{r figure 4a }
fig4a <- ggplot(df_PSA001_valid_merge_sex_ratio_sored, aes(x=Proportion, y=Countries,fill=Sex)) +
  geom_col(alpha = .75)+
  labs(y="Countries") + # , fill="Sex"
  scale_fill_discrete(label=c("female","male")) +
  theme_classic()+
  guides(y="axis_nested") +
  theme(legend.position = "none",
        legend.title = element_text(size = 15,family = "serif"),
        axis.title= element_text(size = 15,family = "serif"),
        axis.text = element_text(size = 10,family = "serif"),
        strip.text = element_text(size = 15,family = "serif"),
        strip.background = element_rect(fill = NA,color = NA),
        panel.border = element_rect(fill = NA,color = "black")) +
  scale_x_continuous(breaks = seq(0, 1, by = 0.1))+
  facet_wrap(~ weird, scales = "free")
# fig4a
```

```{r preproc for age}

df_PSA001_Age_valid <- df_PSA001 %>% 
  dplyr::filter(!is.na(Age)) %>%   ### Removing the NA value in age
  dplyr::filter(Countries %in% PSA001_valid_countries) ### filter countries with > 30 participants

# merge with country code and force the age over 60 in a narrow range for visualization
df_PSA001_Age_valid_countryCode <- merge(df_PSA001_Age_valid, df_regionCode, by.x = "Countries", by.y = "country_iso2") %>%
  dplyr::mutate(Age = ifelse(Age > 60, sample(c(61, 62, 63, 64, 65), 1), Age))

PSA001_valid_countries_sorted <- df_PSA001_Age_valid_countryCode %>%
  dplyr::group_by(Countries) %>%
  dplyr::summarise(medianAge = median(Age)) %>%
  dplyr::ungroup() %>%
  dplyr::arrange(medianAge) %>%
  dplyr::pull(Countries)

df_PSA001_Age_valid_countryCode_sorted <- df_PSA001_Age_valid_countryCode %>%
  dplyr::mutate(Countries = factor(Countries, levels = PSA001_valid_countries_sorted)) %>%
  dplyr::filter(!(Sex=="no" | Sex=="na"))

### Plotting
fig4b <- ggplot(df_PSA001_Age_valid_countryCode_sorted, aes(x=Age, y=Countries, fill=Sex)) +
  geom_density_ridges(scale = 1, alpha = .75, size=0.5) +
  theme_classic() +
  guides(y="axis_nested") +
  labs(y="Countries") +
  scale_fill_discrete(label=c("female","male")) +
  facet_wrap(~weird, scales = "free") +
  coord_cartesian(clip = "off") +
  scale_y_discrete(expand = c(0,0)) +
  scale_x_continuous(expand = c(0,0)) +
  theme(legend.position = "none",
        axis.title= element_text(size = 15,family = "serif"),
        axis.text = element_text(size = 10,family = "serif"),
        panel.border = element_rect(fill = NA,color = "black"),
        strip.background = element_rect(fill = NA,color=NA),
        strip.text = element_text(size = 15,family = "serif"))
# p_PSA001_Age

# save the plot
fig4 <- (fig4a + fig4b) +  plot_annotation(tag_levels = 'A')
ggsave("fig4.pdf", fig4, device = "pdf", width=16, height = 9)
fig4
```

Get the percentage of each age bin and save for JASP
```{r saving figure 4b data for JASP}

PSA001_age_Jasp <- df_PSA001_Age_valid_countryCode_sorted %>%
  dplyr::select(user_id, Countries, Sex, Age) %>%
  dplyr::mutate(ageBins=cut(Age, 
                            breaks=c(0, 10.5, 20.5, 30.5, 40.5, 50.5, 60.5, Inf), 
                            labels=c("0~10","11~20","21~30", "31~40", "41~50", "51~60", ">=61"))) %>%
  dplyr::count(Countries, ageBins) %>%
  dplyr::group_by(Countries) %>%
  dplyr::mutate(freq = (n / sum(n))*100) %>%
  dplyr::ungroup() %>%
  tidyr::complete(Countries, ageBins, fill = list(n = 0, freq = 0)) %>%
  dplyr::mutate(percent = floor(freq),
                indx = freq - percent)

## below we fill the percentage to 100%
filler_idx <- PSA001_age_Jasp %>%
  dplyr::group_by(Countries) %>%
  dplyr::summarise(sum = sum(percent)) %>%
  dplyr::ungroup() # this is necessary, otherwise the for loop doesn't work

PSA001_age_Jasp_filled <- data.frame(matrix(ncol = ncol(PSA001_age_Jasp), nrow = 0))
colnames(PSA001_age_Jasp_filled) <- colnames(PSA001_age_Jasp)

for (ii in 1:nrow(filler_idx)){
  tmp <- PSA001_age_Jasp %>% 
    dplyr::filter(Countries == filler_idx$Countries[ii]) %>%
    dplyr::arrange(desc(indx))
  
  if (filler_idx$sum[ii] < 100) {
    for (jj in seq(100 - filler_idx$sum[ii])){
     tmp$percent[jj] <- tmp$percent[jj] + 1
    }
  }
  PSA001_age_Jasp_filled <- rbind(PSA001_age_Jasp_filled, tmp)
}

PSA001_age_Jasp_filled <- PSA001_age_Jasp_filled %>%
  dplyr::arrange(Countries, ageBins) %>%
  dplyr::select(-indx)

filler_idx2 <- PSA001_age_Jasp_filled %>%
  dplyr::group_by(Countries) %>%
  dplyr::summarise(sum = sum(percent)) %>%
  dplyr::ungroup()  

write.csv(PSA001_age_Jasp_filled, "fig4b_PSA001_age.csv", row.names = F)

PSA001_age_Jasp_filled_wide <- PSA001_age_Jasp_filled %>%
  dplyr::select(-c(n, freq)) %>%
  tidyr::pivot_wider(names_from = "Countries", values_from = "percent")
  
PSA001_age_Jasp_filled_wide %>%
  write.csv(., "Fig4b_ageBin_wide.csv", row.names = F)
```

```{r define multinomial}
# In this test, we hope to test whether the observed distributioni fit with the expected.
# We will use .multBayesBfEquality in JASP, which has three input: 
# .multBayesBfEquality(alphas = a, counts = dataTable, thetas = hyps[[h]])
# alphas, counts, thetas
# alpha is the prior?
# count is the observed (dataTable)
# theta is the hypothesis?
# The most imiportant function in this is the `lgamma()`, which is "natural logarithm of the absolute gamma 
#  ....value of a numeric vector computed using the gamma function."
# Here the BF is the difference between lgamma of prior and after addition the data.
#
# In the case of goodness-of-fit, the expected is ?
#  a              <- setNames(prior$values, prior$levels)
# --> which means assign prior$levels as the names of prior$values
# prior          <- options$priorCounts[[1]]
# --> priorCounts should be the prior part of GUI 

#  hyps  <- .multinomialHypotheses(dataset, options, nlev) # exact equality constraints
# --> .multinomialHypotheses function has two options, no expected value, equal proportion, else:
# expectedDf <- generateExpectedProps(dataset, options, nlevels), hyps <- as.list (expectedDF)
#    fact   <- dataset[[.v(options$factor)]]
#    eProps <- dataset[.v(options$exProbVar)]
#    colnames(eProps) <- options$exProbVar
#    rownames(eProps) <- fact
#
#    return(na.omit(eProps))
#    
#    return(as.data.frame(eProps))

a_tmp <- setNames(c(1,1), c("female", "male"))
counts_tmp <- c(69, 31)
dataTable_tmp <- counts_tmp
names(dataTable_tmp) <- c("female", "male")

fact_tmp <- c("female", "male")
eProps_tmp <- df_sex_ratio_jasp %>% dplyr::arrange(Sex) %>% dplyr::select(Census6)
colnames(eProps_tmp) <- "Census_6"
rownames(eProps_tmp) <- fact_tmp
expectedDf_tmp <- as.data.frame(eProps_tmp)
hyps <- as.list(expectedDf_tmp)

alphas_tmp <- a_tmp
counts_tmp <- dataTable_tmp
thetas_tmp <- hyps[[1]]

if(sum(thetas_tmp) != 1) {
    thetas_tmp <- thetas_tmp/sum(thetas_tmp)
}

expected_tmp <- setNames(sum(counts_tmp)*thetas_tmp, names(counts_tmp))

lbeta.xa_tmp <- sum(lgamma(alphas_tmp + counts_tmp)) - lgamma(sum(alphas_tmp + counts_tmp))
lbeta.a_tmp  <- sum(lgamma(alphas_tmp)) - lgamma(sum(alphas_tmp))

any(rowSums(cbind(thetas_tmp, counts_tmp)) == 0) # FALSE

LogBF10_tmp <- (lbeta.xa_tmp - lbeta.a_tmp) + (0 - sum(counts_tmp * log(thetas_tmp)))
exp(LogBF10_tmp)

BayesMultiNomial <- function(dataset, factor, observed, expected, default_prior = TRUE, prior = NA){
  library(tidyverse)
  fact_level <- dataset %>% dplyr::select(factor) %>% dplyr::pull() #  %>% as.factor(.)
  
  observed_data <- dataset %>% dplyr::select(observed) %>% dplyr::pull()
  names(observed_data) <- fact_level
  expected_data <- dataset %>% dplyr::select(expected) %>% dplyr::pull()
  n_levels <- length(observed_data)
  
  if (default_prior & is.na(prior)) {
    prior <- rep(1, n_levels)
  } else{
    prior <- prior
  }
  
  alphas <- prior
  counts <- observed_data
  thetas <- expected_data
  
  if(sum(thetas) != 1) {
    thetas <- thetas/sum(thetas)
    }
  
  expected <- setNames(sum(counts)*thetas, names(counts))
  
  lbeta.xa <- sum(lgamma(alphas + counts)) - lgamma(sum(alphas + counts))
  lbeta.a  <- sum(lgamma(alphas)) - lgamma(sum(alphas))

  if (any(rowSums(cbind(thetas, counts)) == 0)) {
    LogBF10 <- (lbeta.xa-lbeta.a)
  } else {
    LogBF10 <- (lbeta.xa-lbeta.a) + (0 - sum(counts * log(thetas)))
  }

  BF <- data.frame(LogBF10 = LogBF10,
                   BF10    = exp(LogBF10),
                   BF01    = 1/exp(LogBF10))

  return(list(BF       = BF,
              expected = expected))
  
}

BF10_sex <- BayesMultiNomial(dataset = df_sex_ratio_jasp, factor = "Sex", observed = "PSA001", expected = "Census6")

df_age_ratio_jasp <- read.csv('figure3b_data_1.csv')

BF10_age <- BayesMultiNomial(dataset = df_age_ratio_jasp, factor = "AgeRange", observed = "PsychSample", expected = "Census6")


alphas <- data.frame(count=c(1,1))
counts <- df_sex_ratio_jasp %>% dplyr::arrange(Sex) %>% dplyr::select(PSA001)
thetas <- df_sex_ratio_jasp$Census6[2]/sum(df_sex_ratio_jasp$Census6)


expected <- setNames(sum(counts)*thetas, names(counts))

# compute Bayes factor
lbeta.xa <- sum(lgamma(alphas + counts)) - lgamma(sum(alphas + counts))
lbeta.a  <- sum(lgamma(alphas)) - lgamma(sum(alphas))

 # in this case, counts*log(thetas) should be zero, omit to avoid numerical issue with log(0)
  if (any(rowSums(cbind(thetas, counts)) == 0)) {
    LogBF10 <- (lbeta.xa-lbeta.a)
  } else {
    LogBF10 <- (lbeta.xa-lbeta.a) + (0 - sum(counts * log(thetas)))
  }

  BF <- data.frame(LogBF10 = .clean(LogBF10),
                   BF10    = .clean(exp(LogBF10)),
                   BF01    = .clean(1/exp(LogBF10)))
  
  # Prepare for running the Bayesian Multinomial test
  factorVariable <- multinomialResults$specs$factorVariable
  countVariable  <- multinomialResults$specs$countVariable
  fact           <- dataset[[.v(factorVariable)]]
  fact           <- as.factor(fact)
  nlev           <- nlevels(fact)
  prior          <- options$priorCounts[[1]]
  a              <- setNames(prior$values, prior$levels)
  factNms        <- levels(fact)
  
# Determine observed counts and factor levels
  N <- sum(dataTable)

  # Extract hypotheses
  hyps  <- .multinomialHypotheses(dataset, options, nlev) # exact equality constraints
  nms   <- multinomialResults[["specs"]][["hypNames"]]
  nhyps <- length(hyps)
  
  multinomialResults$mainTable[[nms[h]]] <- .multBayesBfEquality(alphas = a, counts = dataTable, thetas = hyps[[h]])
  }

.multBayesBfEquality <- function(alphas, counts, thetas) {

  # if needed: rescale
  if(sum(thetas) != 1) {
    thetas <- thetas/sum(thetas)
  }

  # expected counts under the null hypothesis (Binomial median)
  expected <- setNames(sum(counts)*thetas, names(counts))

  # compute Bayes factor
  lbeta.xa <- sum(lgamma(alphas + counts)) - lgamma(sum(alphas + counts))
  lbeta.a  <- sum(lgamma(alphas)) - lgamma(sum(alphas))

  # in this case, counts*log(thetas) should be zero, omit to avoid numerical issue with log(0)
  if (any(rowSums(cbind(thetas, counts)) == 0)) {
    LogBF10 <- (lbeta.xa-lbeta.a)
  } else {
    LogBF10 <- (lbeta.xa-lbeta.a) + (0 - sum(counts * log(thetas)))
  }

  BF <- data.frame(LogBF10 = .clean(LogBF10),
                   BF10    = .clean(exp(LogBF10)),
                   BF01    = .clean(1/exp(LogBF10)))

  return(list(BF       = BF,
              expected = expected))
}

# Extra results functions
.multinomialHypotheses <- function(dataset, options, nlevels) {
  # Transform input into a list of hypotheses
  # This function transforms the input into a list of hypotheses
  #
  # Args:
  #   dataset: input dataset
  #   options: user options
  #   nlevels:  number of levels of the factor variable
  #
  # Return:
  #   hypotheses

  hyps <- list()
  if (options$exProbVar == "" && options$hypothesis == "multinomialTest") {
    # Expected probabilities are simple now
    hyps[["Multinomial"]] <- rep(1/nlevels, nlevels)
  } else {
    # First, generate a table with expected probabilities based on input
    expectedDf <- .generateExpectedProps(dataset, options, nlevels)
    # assign each hypothesis to the hyps object
    hyps <- as.list(expectedDf)
  }
  return(hyps)
}

.generateExpectedProps <- function(dataset, options, nlevels) {
  # Parse expected probabilities/counts
  # This function returns a data frame with in each named column the expected
  # probabilities. The column names are the hypothesis names.
  #
  # Args:
  #   dataset: input dataset
  #   options: user options
  #   nlevels: number of levels of the factor variable
  #
  # Return:
  #   expected Probabilities

  if (options$exProbVar != "") {
    # use only exProbVar
    fact   <- dataset[[.v(options$factor)]]
    eProps <- dataset[.v(options$exProbVar)]
    colnames(eProps) <- options$exProbVar
    rownames(eProps) <- fact

    return(na.omit(eProps))

  } else if (length(options$tableWidget) > 0) {
    eProps <- sapply(options$tableWidget, function(x) {
      vals <- unlist(x$values)
      if (sum(vals) == 0)
        vals <- rep(1, length(vals))
      return(vals)
    })

    colnames(eProps) <- sapply(seq_along(options$tableWidget),
                               function(x) paste0("H\u2080 (", letters[x], ")"))
    rownames(eProps) <- options$tableWidget[[1]]$levels

    return(as.data.frame(eProps))
  }
}
```
