---
title: Notebook for  Data Analyses of Chinese Samples in Psychological Subjects [Stage
  1 RR]
author: "Lei Yue (NNU, CCNU); Hu Chuan-Peng (NNU; hcp4715@hotmail.com)"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

This is an [R Markdown](http://rmarkdown.rstudio.com) file for data analyses in the protocol of a meta research which aims at surveying sample characteristics of Chinese sample in Chinese Psychological research. 

In this script, we will use data from PSA 001 project [Jones et al., 2021, *Nature Human Behavior*](https://doi.org/10.1038/s41562-020-01007-2) to exemplify the analyses that we are going to use in our this project.

First, load libraries.

```{r Initialization, message=FALSE, warning=FALSE}
# rm(list = ls())
if (!require("pacman")) install.packages("pacman")

pacman::p_load("tidyverse", "ggh4x","stringr", "patchwork", "BayesFactor", "gtools", "bruceR")

options(scipen=999) 
```

# Bayesian multinomial test

## Background

We decided to use Bayesian multinomial test because it suits our purpose well: it can be used to test whether observed proportions (sex, or age bins, etc) is sample from the population with certain proportion values (e.g., census data). In Frequentists' framework, this can be done by $\chi^2$ test (goodness-of-fit).

Bayesian multinomial test can be done in JASP and a short introduction can be found here: Goss-Sampson, M. (2020, May 17). New Bayesian guide. https://doi.org/10.17605/OSF.IO/CKNXM. 

The function implemented in JASP can be found [here](https://github.com/jasp-stats/jaspFrequencies/blob/d48babf63b14526abaf2c208c8ae769801b6d4db/R/multinomialtestbayesian.R#L384). 

A more detailed explanation for Bayesian multinomial test can be found in ([Sarafoglou et al., 2020](https://doi.org/10.31234/osf.io/bux7p), part 1). Here we also explain it below. 

## How does the JASP's multinomial work?

Essentially, the algorithm in JASP used Savage-Dickey likelihood ratio (Wagenmakers 2010, Cognitive Psychology) to calculate the BF. That is the likelihood of a point given the prior distribution and the likelihood of that same point given the posterior distribution. 

Because multinomial distribution has nice conjugate prior, the Dirichlet distribution, the calculation of posterior of multinomial distribution does not requires MCMC. Thus, it is important to be clear about the following issues:
* What is the prior (the distribution of all possible parameters of multinomial).
* How to calculate the likelihood of the under the prior.
* How posterior is updated.
* How to calculate the likelihood under the posterior (which should be easy if the second question is known)

Answering these questions need dive into the mulitnomial distribution itself.

### Multinomial distribution & Dirichlet distribution

The multinomial distribution is a generalization of the binomial distribution, see [here more](https://en.wikipedia.org/wiki/Multinomial_distribution). 

The probability mass function (PMF) of multinomial distribution is:

$$f(x_1, ..., x_k; n, p_1, ..., p_n) = Pr(X_1 = x_1 \, and \, ...  \, and \, X_k = x_k) = \frac{n!}{x_1! ... x_n!} p_1^{x_1} \times ... \times p_k^{x_k}$$
where $\sum_{i=1}^{k}{x_i=n}$, for non-negative integers $x_1, ..., x_k$

This PMF can be expressed using the gamma function as:

$$f(x_1, ..., x_k; n, p_1, ..., p_n) = \frac{\Gamma(\sum_{i}{x_i +1})}{\prod_{i}\Gamma(x_i + 1)} \prod_{i=1}^{k} p_{i}^{x_i}$$

The distribution of parameters of multinomial distribution $\theta = (\theta_1, \theta_2, ..., \theta_K)$ is a Dirichlet distribution with concentration parameters ($\alpha_1$, $\alpha_2$, ..., $\alpha_k$, where $\alpha > 0$:

$$p(\theta) = p(\theta_1, \theta_2, ..., \theta_k) = \frac {\Gamma(\sum_{k=1}^k \alpha_k)} {\sum_{k=1}^k\Gamma (\alpha_k)} \prod_{k=1}^k \theta_k^{\alpha_{k}-1} = \frac {1} {B(\alpha)} \prod_{k=1}^k \theta_k^{\alpha_{k}-1} $$

The posterior is also a Dirichlet distribution:

$$p(\theta | x) = \frac {\Gamma(N + \sum_{k=1}^k \alpha_k)} {\sum_{k=1}^k\Gamma (x_k + \alpha_k)} \prod_{k=1}^k \theta_k^{x_k + \alpha_{k}-1} = \frac {1} {B(\alpha + x)} \prod_{k=1}^k \theta_k^{x+k + \alpha_{k}-1} $$

If $H_0$ is a point null hypothesis, which is often specified as all parameters are equal. The alternative hypothesis, $H_a$, or $H_e$ in [Sarafoglou et al., 2020](https://doi.org/10.31234/osf.io/bux7p), is a distribution, which states that all category proportions are free to vary without any ordinal restriction. 

### BF for multinomial test

Because $H_0$ is a point null hypothesis, the $BF_{0e}$ can be calculated using Savage-Dickey Ratio:

$$BF_{0e} = \frac {p(x | H_0)}{p(x | H_e)}  = \frac {p(x | \theta = c, H_e)}{\frac {p(x | \theta = c, H_e) p(\theta = c | H_e)} {p(\theta = c | x, H_e)}} = \frac {p(\theta = c \, | \, x, He)} {p(\theta = c \, | \, He)} $$

"The underlying principle of the Savage-Dickey density ratio is to compute the Bayes factor by dividing the height of the posterior density under He at the point of interest (i.e., c) by the height of the prior density under He at the same point."

Here prior, ($\alpha_1, ...$) is the parameters of Dirichlet distribution $Dir(\alpha_1, \alpha_2, ..., \alpha_k)$, which is not equal to $c$. $c$ is a point in the space that defined by Dirichlet distribution. The parameter $(\alpha_1 = 1, \alpha_1 = 2, ..., \alpha_K = 1)$ of Dirichlet distribution means that $c$ is equally possible with other set of $\theta$.

To understand the Dirichlet distribution and it's parameters, please see [here](https://en.wikipedia.org/wiki/Dirichlet_distribution).


Using the prior and posterior distribution of Dirichlet, we can directly calculated the $BF_{0e}$

$$BF_{0e} = \frac {p(\theta = c \, | \, x, H_e)} {p(\theta = c \, | \, H_e)} =  \frac {1} {B(x+\alpha)} \prod_{k=1}^k \theta_k^{x_k + \alpha_{k}-1} / \frac {1} {B(\alpha)} \prod_{k=1}^k \theta_k^{\alpha_{k}-1} $$
$$BF_{0e} = \frac {p(\theta = c \, | \, x, H_e)} {p(\theta = c \, | \, H_e)} = \frac {Beta(\alpha)} {Beta(x + \alpha)} * \frac {\prod_{k=1}^k \theta_k^{x_k + \alpha_{k}-1}} {\prod_{k=1}^k \theta_k^{\alpha_{k}-1}}$$

$$BF_{e0} = 1/BF_{0e} = \frac {Beta(x + \alpha)} {Beta( \alpha)} * \frac {\prod_{k=1}^k \theta_k^{\alpha_{k}-1}} {\prod_{k=1}^k \theta_k^{x_k + \alpha_{k}-1}} $$
The above is the formula for the analytically solution of BF in R.

$$ log(BF_{e0}) = log(Beta(x + \alpha))- log(Beta( \alpha)) + (\sum_{k=1}^k log(\theta_k *(\alpha_{k}-1)) - \sum_{k=1}^k log(\theta_k * (x_k + \alpha_{k}-1))) $$

$$ log(BF_{e0}) = log(Beta(x + \alpha))- log(Beta( \alpha)) + (\sum_{k=1}^k log(\theta_k *(\alpha_{k}-1)) - (\sum_{k=1}^k log(\theta_k * x_k) +  \sum_{k=1}^k log(\theta_k * (\alpha_{k}-1)))) = log(Beta(x + \alpha))- log(Beta( \alpha)) - \sum_{k=1}^k log(\theta_k * x_k) $$

### Algorithm in R


```
lbeta.xa <- sum(lgamma(alphas + counts)) - lgamma(sum(alphas + counts))
lbeta.a  <- sum(lgamma(alphas)) - lgamma(sum(alphas))

LogBF10 <- (lbeta.xa-lbeta.a) + (0 - sum(counts * log(thetas)))  
```

Here, `alphas` defined the prior Dirichlet distribution, usually a vector of 1, `counts` are the observed frequencies.


To use the algorithm in R, we defined a function here:

```{r define BF for Multinomial test, message=FALSE, warning=FALSE}
BayesMultiNomial <- function(dataset, factor, observed, expected, default_prior = TRUE, prior = NA){
  # datase - the input dataframe
  # factor - column name of the factor,
  # observed - column name of the column contains counts information for the observed,
  # expected - column name of the column contains counts information for the expected,
  # default_prior - whether use the default, defused prior
  # prior - priors defined by users
  
  fact_level <- dataset %>% dplyr::select(all_of(factor)) %>% dplyr::pull()
  observed_data <- dataset %>% dplyr::select(all_of(observed)) %>% dplyr::pull()
  names(observed_data) <- fact_level
  expected_data <- dataset %>% dplyr::select(all_of(expected)) %>% dplyr::pull()
  n_levels <- length(observed_data)
  
  
  if (default_prior & all(is.na(prior))) {
    prior <- rep(1, n_levels)
  } else{
    if (is.character(prior)){
      prior <- dataset %>% dplyr::select(all_of(prior)) %>% dplyr::pull()
    } else if (is.array(prior)){
      prior <-  prior
    } else if (is.numeric(prior)){
      prior <-  prior
    } else{
      print("prior much a column of the input data or a vector")
    }
  }
  
  alphas <- prior
  counts <- observed_data
  thetas <- expected_data
  
  if(sum(thetas) != 1) {
    thetas <- thetas/sum(thetas)
    }
  
  expected <- setNames(sum(counts)*thetas, names(counts))
  
  lbeta.xa <- sum(lgamma(alphas + counts)) - lgamma(sum(alphas + counts))
  lbeta.a  <- sum(lgamma(alphas)) - lgamma(sum(alphas))

  if (any(rowSums(cbind(thetas, counts)) == 0)) {
    LogBF10 <- (lbeta.xa-lbeta.a)
  } else {
    LogBF10 <- (lbeta.xa-lbeta.a) + (0 - sum(counts * log(thetas))) 
  }

  BF <- data.frame(LogBF10 = LogBF10,
                   BF10    = exp(LogBF10),
                   BF01    = 1/exp(LogBF10))

  return(list(BF       = BF,
              expected = expected))
  
}
```

### Test the default prior
To test whether the current non-informative prior is reasonable, we conducted a simulation to test the sensitivity.

We tested the false positive rate of the current setting and power of the current setting under different deviation from the expected. 

For sex ratio, we used the probability of male as the parameter, as the expected proportion of female and male are both 50, we used the $Y \sim Binomial(p = 0.5)$ as the null model, any deviation from $0.5$ will be viewed as different from the null effect. 

**False Positive Rate**: The proportion of BF01 that greater than 3.

**Power**: The proportion of BF10 that greater than 3.

```{r test default prior for sex ratio }
# define a function to run the simulation for sex ratio
Sim_Power_binormial <- function(seed = 12345, sim_N = 1000, prob_sim = 0.5, nil_effect = 0.5){
  set.seed(seed)
  
  sim_1 <- data.frame(obs = rbinom(1000, size = 100, prob = prob_sim))
  sim_1$sex <- "male"
  sim_1$iter <- seq(sim_N)
  sim_2 <- data.frame(obs = 100 - sim_1$obs)
  sim_2$sex <- "female"
  sim_2$iter <- seq(sim_N)
  
  sim <- sim_1 %>% 
    dplyr::bind_rows(., sim_2) %>% 
    dplyr::arrange(iter)
  
  test_BF <- data.frame(matrix(nrow = sim_N, ncol = 3))
  colnames(test_BF) <- c("Iter", "1st_prop", "BF10")
  
  for (ii in seq(sim_N)){
    test_df <- sim %>%
      dplyr::filter(iter == ii) %>%
      dplyr::mutate(expected = 50)
    
    # test_df1$obs <- c(test_df1$expected[1] - ii, test_df1$expected[2] + ii)
    tmp_BF <- BayesMultiNomial(test_df, factor = 'sex', observed = 'obs', expected = 'expected')
    test_BF$Iter[ii] <- ii
    test_BF$`1st_prop`[ii] <- test_df$expected[1] - ii
    # test_BF$`log_BF10`[ii] <- tmp_BF$BF$LogBF10
    test_BF$`BF10`[ii] <- tmp_BF$BF$BF10
    
  }
  
  BF_power <- data.frame(matrix(nrow = 1, ncol = 5))
  colnames(BF_power) <- c("Prob", "Category", "BF_1", "BF_3", "BF_6")
  
  if (prob_sim == nil_effect) {
    BF_power$Prob <- prob_sim
    BF_power$Category <- "Evidence_for_Null"
    BF_power$BF_1 <- sum(test_BF$BF10 < 1)/1000 
    BF_power$BF_3 <- sum(test_BF$BF10 <= 1/3)/1000 
    BF_power$BF_6 <- sum(test_BF$BF10 <= 1/ 6)/1000 
  } else {
    BF_power$Prob <- prob_sim
    BF_power$Category <- "Evidence_for_Effect"
    BF_power$BF_1 <- sum(test_BF$BF10 > 1)/1000 
    BF_power$BF_3 <- sum(test_BF$BF10 >= 3)/1000 
    BF_power$BF_6 <- sum(test_BF$BF10 >= 6)/1000 
  }
  return(BF_power)
}

### false positive rate
Sim_False_Pos_Binom <- Sim_Power_binormial()

### simulation for Power
probs <- seq(0.5, 0.7, 0.01)

rm(res_bf_power)
for (jj in (seq(length(probs)))){
  tmp_power <- Sim_Power_binormial(seed = 1000, prob_sim = probs[jj])
  if (exists("res_bf_power")){
    res_bf_power <- rbind(res_bf_power, tmp_power)
  } else {
    res_bf_power <- tmp_power
  }
}

res_bf_power %>% 
  ggplot2::ggplot(., aes(x = Prob, y = BF_3)) +
  ggplot2::geom_point() + 
  ggplot2::geom_hline(yintercept = 0.8) +
  ggplot2::theme_classic()
```

Our simulation found that, for sex ratio, the current setting (prior), we can have detect deviation from p = 0.5 with more 80% of the times if the difference is greater than 0.17.


For age bins.


First, the effect size is more complicated: https://github.com/jasp-stats/jasp-issues/issues/1652, tried but did not use this index, need to discuss with Alex further.

For K number of population frequencies p_{1}, p_{2}, .., p_{K-1}, p_{K} this would be a K-1 dimensional vector g such that

$$g_{i} = \log( p_{I} / p_{K})$$

Thus, $g$ is the vector

$$ g = (\log(p_{1} / p_{K}), \log(p_{2} / p_{K}), …, \log(p_{K-1} / p_{K}))$$

Similarly, for observed frequencies $\hat{p}{1}$, $\hat{p}{2}$, …, $\hat{p}{K-1}$, $\hat{p}{K}$ I would create an analogous K-1 dimension vector $\hat{g}$ such that

$$\hat{g}_{i} = \log( \hat{p}_{i} / \hat{p}_{K})$$

Thus, $\hat{g}$ is the vector

$$\log(\hat{p}_{1}/ \hat{p}_{K}), log(\hat{p}_{2}/ \hat{p}_{K}), …, log(\hat{p}_{K-1}/ \hat{p}_{K})$$

The observed effect size would then be the distance between $g$ and $\hat{g}$, which is defined as

$$\sqrt{\sum_{i=1}^{K-1} (\hat{g}_{i} - g_{i})^{2}}$$

An alternative would be to use vectors m of the form

$$m_{i} = \sqrt{p_{i}}$$


```{r test default prior for age ratio }
seed = 1000
sim_N = 1000
alpha_stim <- c(1,1,1,1,1)
sim_probs <- data.frame(gtools::rdirichlet(n = sim_N, alpha = rep(10, 5)))
colnames(sim_probs) <- paste0("bin", seq(5))
bruceR::Describe(sim_probs)

### using the distance index from Alex, does not work
# calc_dist <- function(expected, observed){
#   g_dist <- sqrt(sum((log(observed[1]/observed[5]) - log(expected[1]/expected[5]))^2 +
#                  (log(observed[1]/observed[5]) - log(expected[1]/expected[5]))^2 +
#                  (log(observed[1]/observed[5]) - log(expected[1]/expected[5]))^2 +
#                  (log(observed[1]/observed[5]) - log(expected[1]/expected[5]))^2
#     ))
#   return(g_dist)
# }
# 
# rm('g_dists')
# for (kk in seq(sim_N)){
#   prob = sim_probs[kk, ]
#   dist <- calc_dist(expected = nil_effect, observed = prob)
#   
#   if (exists('g_dists')){
#     g_dists <- c(g_dists, dist)
#   } else {
#     g_dists <- dist
#   }
# }
# 
# sim_probs$dist <- g_dists
# sim_probs <- sim_probs %>% dplyr::arrange(dist)
# 
# #hist(sim_probs$dist)
# summary(sim_probs)

Sim_Power_mult_calc <- function(seed = 12345, 
                           sim_N = 1000, 
                           sim_prob = c(0.2, 0.2, 0.2, 0.2, 0.2), 
                           nil_effect = c(0.2, 0.2, 0.2, 0.2, 0.2)){
  library(tidyverse)
  
  set.seed(seed)

  tmp_data <- data.frame(rmultinom(n=sim_N, size=100, prob = sim_prob))  # %>%

  test_BF <- data.frame(matrix(nrow = sim_N, ncol = 2))
  colnames(test_BF) <- c("Iter", "BF10")
  for (ii in seq(sim_N)){
      sim_data1 <- tmp_data[, ii]
      sim_data2 <- nil_effect * 100
      test_df <- data.frame(expected = sim_data2,
                            obs = sim_data1)%>%
        dplyr::mutate(ageBins = paste0('bin', seq(5)))
      
      tmp_BF <- BayesMultiNomial(test_df, 
                                 factor = 'ageBins', 
                                 observed = 'obs', 
                                 expected = 'expected')
      test_BF$Iter[ii] <- ii
      test_BF$`BF10`[ii] <- tmp_BF$BF$BF10
      
  }
  
  BF_power <- data.frame(matrix(nrow = 1, ncol = 5))
  colnames(BF_power) <- c("Prob", "Category", "BF_1", "BF_3", "BF_6")
  
  BF_power$Prob <- paste0(round(sim_prob, 3), collapse = ';')
  
  if (sum(sim_prob == nil_effect)==length(sim_prob)) {
    
    BF_power$Category <- "Evidence_for_Null"
    BF_power$BF_1 <- sum(test_BF$BF10 < 1)/1000 
    BF_power$BF_3 <- sum(test_BF$BF10 <= 1/3)/1000 
    BF_power$BF_6 <- sum(test_BF$BF10 <= 1/ 6)/1000 
  } else {
    BF_power$Category <- "Evidence_for_Effect"
    BF_power$BF_1 <- sum(test_BF$BF10 > 1)/1000 
    BF_power$BF_3 <- sum(test_BF$BF10 >= 3)/1000 
    BF_power$BF_6 <- sum(test_BF$BF10 >= 6)/1000 
  }
  return(BF_power)
}

### flase positive rate for this case
Sim_False_Pos_mult <- Sim_Power_mult_calc()

# probs <- seq(0.5, 0.7, 0.01)

Sim_Power_mult <- function(seed = 12345,
                           sim_N_probs = 10000, # used a large number to sample in the full param space
                           alpha_sim = 1){
  set.seed(seed)
  
  sim_probs <- data.frame(gtools::rdirichlet(n = sim_N_probs, alpha = rep(alpha_sim, 5)))
  colnames(sim_probs) <- paste0("bin", seq(5))
  rm('res_bf_power')
  for (jj in (seq(nrow(sim_probs)))){ # 
    tmp_power <- Sim_Power_mult_calc(sim_prob = sim_probs[jj, 1:5],
                                nil_effect = c(0.2, 0.2, 0.2, 0.2, 0.2))
    tmp_power$alpha_sim <- alpha_sim
    if (exists("res_bf_power")){
      res_bf_power <- rbind(res_bf_power, tmp_power)
    } else {
      res_bf_power <- tmp_power
    }
  }
  return(res_bf_power)
}

test <- Sim_Power_mult(sim_N_probs = 5, alpha_sim = 10)

rm('Res_Sim')
for (alph_sim in c(1:5, 10)){
  # print(alph_sim)
  Sim_res_tmp <-  Sim_Power_mult(alpha_sim = alph_sim)

  if (exists("Res_Sim")){
      Res_Sim <- rbind(Res_Sim, Sim_res_tmp)
    } else {
      Res_Sim <- Sim_res_tmp
    }
  
}

Res_Sim <- Res_Sim %>%
  dplyr::arrange(alpha_sim, BF_3)

Res_Power <- Res_Sim %>%
  dplyr::group_by(alpha_sim) %>%
  dplyr::filter(BF_3 >=0.8) %>%
  dplyr::summarise(n = n()/1000)

Res_Sim %>% 
  dplyr::group_by(alpha_sim) %>%
  dplyr::mutate(Iter = seq(n())) %>%
  dplyr::ungroup() %>%
  ggplot2::ggplot(., aes(x = Iter, y = BF_3, group = alpha_sim)) +
  ggplot2::geom_point(aes(color = as.factor(alpha_sim))) + 
  ggplot2::geom_hline(yintercept = 0.8) +
  ggplot2::theme_classic()
```


For the age ratio:


# Load data and preprocess the data

```{r Loading data, message=FALSE, warning=FALSE}
load("df_chinese_subj_rr_stage1.RData")
```

```{r disposal data, message=FALSE, warning=FALSE}

df_census6_age <- df_census6 %>% 
  dplyr::select(1,3,4) %>% 
  dplyr::rename(ageBins=1,
                male=2,
                female=3) %>% 
  dplyr::mutate_at(c("ageBins","male","female"),as.numeric) %>% 
  na.omit() %>% 
  dplyr::add_row(ageBins=100,
                 male=8852,
                 female=27082) %>%  ###100 represent 100 years old and above
  tidyr::pivot_longer(-ageBins,names_to = "sex",values_to = "num")
 
df_census7_age <- df_census7 %>% 
  dplyr::select(1,3,4) %>% 
  dplyr::rename(ageBins=1,
                male=2,
                female=3) %>% 
  dplyr::mutate_at(c("ageBins","male","female"),as.numeric) %>% 
  na.omit() %>% 
  dplyr::add_row(ageBins=100,
                 male=35129,
                 female=83737) %>% ###100 represent 100 years old and above
  tidyr::pivot_longer(-ageBins,names_to = "sex",values_to = "num")
  
```

# Test three hypotheses

## Test the 1st hypothesis
*This can only be done after collecting data.*

## Testing the 2nd hypothesis

Here we will test whether the sex ratio and age distribution from Chinese psychological studies are similar to that of the census data. As a comparison, we also compared that data from sociology, CFPS 2018, to the census data too. We use Bayesian multinomial test (Bayesian goodness-of-fit test) to examine whether the observed (Chinese psychological samples) fit the expected (7th Census data). 

$H_0$: $\theta = c$, where $c$ is defined by census data or CFPS 2018;
$H_1$: $\theta$ is free to vary.

### Sex distribution

```{r H2a sex, message=FALSE, warning=FALSE}
df_PSA001_sex_CN <- df_PSA001 %>%
  dplyr::filter(Countries == "CN") %>%
  dplyr::count(Sex) %>%
  dplyr::mutate(Proportion = round(n / sum(n), 2) * 100,
                Site = "PSA001",
                Sex = ifelse(Sex == "f", 'female', 'male' )) %>%
  dplyr::select(Site, Sex, Proportion)

df_census7_sex <- df_census7 %>%
  dplyr::select(c(6,7)) %>%        
  dplyr::slice(c(6)) %>%
  dplyr::rename(male=1, 
                female=2) %>%
  dplyr::mutate(Site = "Census7") %>%
  tidyr::pivot_longer(c(male, female), 
                      names_to = "Sex",
                      values_to = "Proportion") %>%
  dplyr::mutate(Proportion = round(as.numeric(Proportion), 0))

df_CFPS2018_sex <- df_CFPS2018 %>%
  dplyr::rename(Sex = QA002) %>%
  dplyr::count(Sex) %>%
  dplyr::filter(!is.na(Sex)) %>%
  dplyr::mutate(Proportion = round(n / sum(n), 2) * 100,
                Site = "CFPS2018",
                Sex = ifelse(Sex == 1, "male", "female")) %>%
  dplyr::select(Site, Sex, Proportion)

df_sex_ratio <- rbind(df_census7_sex, df_CFPS2018_sex, df_PSA001_sex_CN)

### get the data for Bayesian mutlinomial test as in JASP
df_sex_ratio_jasp <- df_sex_ratio %>%
  tidyr::pivot_wider(names_from = Site,
                     values_from = Proportion)
## save to csv
write.csv(df_sex_ratio_jasp, "df_sex_ratio_jasp.csv", row.names=FALSE)

BF_h2a_sex_psych <- BayesMultiNomial(dataset = df_sex_ratio_jasp, factor = "Sex", observed = "PSA001", expected = "Census7")
BF_h2a_sex_cfps <- BayesMultiNomial(dataset = df_sex_ratio_jasp, factor = "Sex", observed = "CFPS2018", expected = "Census7")

BF_h2a_sex_psych_2 <- BayesMultiNomial(dataset = df_sex_ratio_jasp, factor = "Sex", observed = "PSA001", expected = "Census7", prior = "Census7")
BF_h2a_sex_cfps_2 <- BayesMultiNomial(dataset = df_sex_ratio_jasp, factor = "Sex", observed = "CFPS2018", expected = "Census7", prior = "Census7")

fig3a <- ggplot(df_sex_ratio, aes(Site, Proportion,fill=Sex)) +
  geom_col() +
  theme_classic()+
  xlab("Data sources") +
  theme(legend.position = "bottom",
        legend.key.size = unit(20,"pt"),
        legend.box.spacing = unit(4,"pt"),
        legend.title = element_blank(),
        axis.title = element_text(size = 16, family = "serif"),
        legend.text = element_text(size = 16, family = "serif"),
        axis.text = element_text(size =16, family = "serif"))
#fig3a
```

We found strong evidence for the $H_1$ that the sex ratio from PSA001 is different from that of Census data, with $Log(BF_{10})$ = `r BF_h2a_sex_psych$BF$LogBF10`. On the contrast, for the CFPS data, we found moderate evidence for the $H_0$ that sex ratio from CFPS2018 is not different from that of Census data, $Log(BF_{10})$ = `r BF_h2a_sex_cfps$BF$LogBF10`

### Age distribution

Here we will compare the age distribution of samples from psychological studies (PSA 001 as the example) and the Census data.

```{r define a func for propotion of census age bins, message=FALSE, warning=FALSE}
Func_census_Age_Prop <- function(df_census, break_names, label_names,level_names,wider_form=TRUE){
  #### function for calculating the proportion of age bins based on the break_names and label_names
  # df: the input data, with ageBins,male, female,and site
  # break_names, a vector of number
  # label_names, a vector of string
  # level_names, a factor
  #
  # return a wide-format data frame for further BF calculation
  ####
  
  df_tmp_census <- df_census %>%
    dplyr::mutate(ageBins=cut(ageBins,
                              breaks=break_names,
                              labels=label_names)) %>%
    group_by(ageBins,sex) %>% 
    summarise(num=sum(num)) %>% 
    ungroup() %>% 
    dplyr::mutate(freq=(num/sum(num))*100) %>% 
    dplyr::mutate(percent = floor(freq),
                  indx = freq - percent,
                  site="census7")
  
  df_tmp_census$ageBins= factor(df_tmp_census$ageBins,levels=level_names)

  ## below we fill the percentage to 100%
  filler_idx_census <- df_tmp_census %>%
    dplyr::group_by(site) %>% 
    dplyr::summarise(sum = sum(percent)) %>%
    dplyr::ungroup() 

  df_tmp_filled_census <- data.frame(matrix(ncol = ncol(df_tmp_census), nrow = 0))
  colnames(df_tmp_filled_census) <- colnames(df_tmp_census)


  for (ii in 1:nrow(filler_idx_census)){
    tmp_census <- df_tmp_census %>% 
      dplyr::filter(site == filler_idx_census$site[ii]) %>%
      dplyr::arrange(desc(indx))
    
    if (filler_idx_census$sum[ii] < 100) {
      for (jj in seq(100 - filler_idx_census$sum[ii])){
        tmp_census$percent[jj] <- tmp_census$percent[jj] + 1
      }
    }
    df_tmp_filled_census <- rbind(df_tmp_filled_census, tmp_census)
  }
  
  df_tmp_filled_census <- df_tmp_filled_census %>%
    dplyr::arrange(ageBins, sex)

  if (wider_form){
    df_tmp_filled_census <- df_tmp_filled_census %>%
      dplyr::select(-c(num, freq, indx)) %>%
      tidyr::pivot_wider(names_from = "ageBins", values_from = "percent") 
  }

  return(df_tmp_filled_census)
}
```

```{r define a func for proportion of PSA001 age bins, message=FALSE, warning=FALSE}
Func_PSA001_Age_Prop <- function(df_PSA, break_names, label_names, level_names,wider_form=TRUE){
  #### function for calculating the proportion of age bins based on the break_names and label_names
  # df: the input data, with user_id, Countries, Sex, and Age
  # break_names, a vector of number
  # label_names, a vector of string
  # level_names, a factor
  #
  # return a wide-format data frame for further BF calculation
  ####
  
  df_tmp_PSA <- df_PSA %>%
    dplyr::select(user_id, Countries, Sex, Age) %>%
    dplyr::filter(Countries=="CN") %>% 
    dplyr::filter(!is.na(Age)) %>% 
    dplyr::mutate(ageBins_pyr=cut(Age, 
                              breaks=break_names,  
                              labels=label_names)) %>%
    dplyr::count(ageBins_pyr, Sex) %>%
    dplyr::mutate(freq = (n / sum(n))*100) %>%
    tidyr::complete(ageBins_pyr, Sex,fill = list(n = 0, freq = 0)) %>%
    dplyr::mutate(percent = floor(freq),
                  indx = freq - percent) %>% 
    dplyr::mutate(site="PSA001",
                  Sex=ifelse(Sex=="f","female_PSA","male_PSA"))
    
  
  df_tmp_PSA$ageBins_pyr= factor(df_tmp_PSA$ageBins_pyr,levels=level_names)
  
  ## below we fill the percentage to 100%
  filler_idx_PSA <- df_tmp_PSA %>%
    dplyr::group_by(site) %>%
    dplyr::summarise(sum = sum(percent)) %>%
    dplyr::ungroup() 

  df_tmp_filled_PSA <- data.frame(matrix(ncol = ncol(df_tmp_PSA), nrow = 0))
  colnames(df_tmp_filled_PSA) <- colnames(df_tmp_PSA)

  for (ii in 1:nrow(filler_idx_PSA)){
    tmp_PSA <- df_tmp_PSA %>% 
      dplyr::filter(site == filler_idx_PSA$site[ii]) %>%
      dplyr::arrange(desc(indx))
    
    if (filler_idx_PSA$sum[ii] < 100) {
      for (jj in seq(100 - filler_idx_PSA$sum[ii])){
       tmp_PSA$percent[jj] <- tmp_PSA$percent[jj] + 1
      }
    }
    df_tmp_filled_PSA <- rbind(df_tmp_filled_PSA, tmp_PSA)
  }
  df_tmp_filled_PSA <- df_tmp_filled_PSA %>%
    dplyr::arrange(ageBins_pyr,Sex)
  
  if (wider_form){
    df_tmp_filled_PSA <- df_tmp_filled_PSA %>%
      dplyr::select(-c(n, freq, indx)) %>%
      tidyr::pivot_wider(names_from = "ageBins_pyr", values_from = "percent") 
  }
  
  
  return(df_tmp_filled_PSA)
}
```
#### Age bins [set 1]: demogrphic age bins

```{r H2b ageBins plot, message=FALSE, warning=FALSE}
df_PSA001_Age_CN <- Func_PSA001_Age_Prop(df_PSA001,
                                         break_names =c(-Inf,4.5,9.5,14.5,19.5,24.5,
                                                        29.5,34.5,39.5,44.5,49.5,
                                                        54.5,59.5,64.5,69.5,74.5,
                                                        79.5,84.5,89.5,94.5,Inf),
                                         label_names = c("0~4","5~9","10~14","15~19","20~24",
                                     "25~29","30~34","35~39","40~44","45~49",
                                     "50~54","55~59","60~64","65~69","70~74",
                                     "75~79","80~84","85~89", "90~94",">=95"),
                                     level_names = c("0~4","5~9","10~14","15~19","20~24",
                                     "25~29","30~34","35~39","40~44","45~49",
                                     "50~54","55~59","60~64","65~69","70~74",
                                     "75~79","80~84","85~89", "90~94",">=95"),
                     wider_form = FALSE)
                                          

df_census7_age_new <- Func_census_Age_Prop(df_census7_age,
                     break_names = c(-Inf,4.5,9.5,14.5,19.5,24.5,
                                     29.5,34.5,39.5,44.5,49.5,
                                     54.5,59.5,64.5,69.5,74.5,
                                      79.5,84.5,89.5,94.5,Inf),
                     label_names = c("0~4","5~9","10~14","15~19","20~24",
                                     "25~29","30~34","35~39","40~44","45~49",
                                     "50~54","55~59","60~64","65~69","70~74",
                                     "75~79","80~84","85~89", "90~94",">=95"),
                     level_names = c("0~4","5~9","10~14","15~19","20~24",
                                     "25~29","30~34","35~39","40~44","45~49",
                                     "50~54","55~59","60~64","65~69","70~74",
                                     "75~79","80~84","85~89", "90~94",">=95"),
                     wider_form = FALSE)

###plotting
fig3b <- ggplot(data= df_census7_age_new, aes(x=ageBins, y=ifelse(sex=="male", -percent, percent), fill=sex)) +
  geom_col(alpha=0.5, width = 1) +
  geom_line(data = df_PSA001_Age_CN, aes(x=ageBins_pyr,
                                      y = ifelse(Sex == "male_PSA", -percent/2.5, percent/2.5),
                                      group=Sex,color="PSA001"), size=1, inherit.aes = FALSE) +
  scale_y_continuous(limits = c(-15,15),sec.axis = sec_axis(~.*2.5, name = "Proportion (PSA001)")) +
  coord_flip() +
  labs(y="Proportion (census data)", x = "Age bins", color=NULL)+
  annotate("text",label= "italic(Male)",x=19,y=-2,parse=TRUE,size=8, family = "serif") +
  annotate("text",label= "italic(Female)",x=19,y=3,parse=TRUE,size=8,family = "serif") +
  scale_color_manual(values = c("red","blue"))+
  theme_classic()+
  theme(panel.border =element_rect(fill=NA,color="black"),
        legend.position ="bottom",
        legend.box.spacing = unit(2,"pt"),
        legend.text = element_text(size = 16, family = "serif"),
        legend.title = element_blank(),
        axis.title = element_text(size = 16,family = "serif"),
        axis.text = element_text(size = 16,family = "serif"))

fig3 <- fig3a + fig3b +  plot_annotation(tag_levels = 'A')
ggsave("fig3.pdf", fig3, device = "pdf", width=16, height = 9)

fig3
```

Also get the data for Bayesian multinomial test
```{r test H2b using BMT, message=FALSE, warning=FALSE}
### PAS001' age is divided into ten years
df_PSA001_Age_CN_jasp_interval10 <- Func_PSA001_Age_Prop(df_PSA001,
                                                          break_names = c(0, 9.5, 19.5, 29.5, 30.5, 40.5, 59.5, Inf),
                                                          label_names = c("0~9","10~19","20~29", "30~39", "40~49", "50~59", ">=60"),
                                                          level_names = c("0~9","10~19","20~29", "30~39", "40~49", "50~59", ">=60"),
                                                          wider_form = FALSE) %>% 
  dplyr::group_by(ageBins_pyr) %>% 
  dplyr::summarise(percent=sum(percent)) %>%
  dplyr::ungroup() %>% 
  dplyr::rename(PSA001_CN=percent,
                ageBins=ageBins_pyr)


### PSA001' age is divided into stages of development
df_PSA001_Age_CN_Jasp_interval_stages <- Func_PSA001_Age_Prop(df_PSA001,
                                                              break_names = c(0, 17.5, 25.5, 40.5, 59.5, Inf),
                                                              label_names = c("0~17","18~25","26~40", "41~59", ">=60"),
                                                              level_names = c("0~17","18~25","26~40", "41~59", ">=60"),
                                                              wider_form = FALSE) %>%
  dplyr::group_by(ageBins_pyr) %>% 
  dplyr::summarise(percent=sum(percent)) %>%
  dplyr::ungroup() %>% 
  dplyr::rename(PSA001_CN=percent,
                ageBins=ageBins_pyr)
  

###Census7' age is divided into ten years
df_census7_age_jasp_interval10 <- Func_census_Age_Prop(df_census7_age,
                                                       break_names = c(-Inf, 9.5, 19.5, 29.5, 30.5, 40.5, 59.5, Inf),
                                                       label_names = c("0~9","10~19","20~29", "30~39", "40~49", "50~59", ">=60"),
                                                       level_names = c("0~9","10~19","20~29", "30~39", "40~49", "50~59", ">=60"),
                                                       wider_form = FALSE) %>% 
  dplyr::group_by(ageBins) %>% 
  dplyr::summarise(percent=sum(percent)) %>%
  dplyr::ungroup() %>% 
  dplyr::rename(Census7=percent)


###Census' age is divided into the stages of development
df_census7_age_jasp_interval_stages <- Func_census_Age_Prop(df_census7_age,
                                                       break_names = c(-Inf, 17.5, 25.5, 40.5, 59.5, Inf),
                                                       label_names = c("0~17","18~25","26~40", "41~59", ">=60"),
                                                       level_names = c("0~17","18~25","26~40", "41~59", ">=60"),
                                                       wider_form = FALSE) %>% 
  dplyr::group_by(ageBins) %>% 
  dplyr::summarise(percent=sum(percent)) %>%
  dplyr::ungroup() %>% 
  dplyr::rename(Census7=percent)


df_age_jasp_interval10 <- df_PSA001_Age_CN_jasp_interval10 %>% 
  dplyr::left_join(.,df_census7_age_jasp_interval10)

df_age_jasp_interval_stages <- df_PSA001_Age_CN_Jasp_interval_stages %>% 
  dplyr::left_join(.,df_census7_age_jasp_interval_stages)


# save the CSV to compare the BayesMultiNomial with the result in JASP
write.csv(df_age_jasp_interval_stages, "df_age_jasp_interval_stages.csv", row.names = FALSE)

write.csv(df_age_jasp_interval10, "df_age_jasp_interval10.csv", row.names = FALSE)

BF_h2b_age_psych_interval10 <- BayesMultiNomial(dataset = df_age_jasp_interval10, 
                                     factor = "ageBins", 
                                     observed = "PSA001_CN",
                                     expected = "Census7")

BF_h2b_age_psych_interval10_2 <- BayesMultiNomial(dataset = df_age_jasp_interval10, 
                                     factor = "ageBins", 
                                     observed = "PSA001_CN",
                                     expected = "Census7",
                                     prior = "Census7")

BF_h2b_age_psych_interval_stages <- BayesMultiNomial(dataset = df_age_jasp_interval_stages,
                                                     factor = "ageBins",
                                                     observed = "PSA001_CN",
                                                     expected = "Census7")

BF_h2b_age_psych_interval_stages_2 <- BayesMultiNomial(dataset = df_age_jasp_interval_stages,
                                                     factor = "ageBins",
                                                     observed = "PSA001_CN",
                                                     expected = "Census7",
                                                     prior = "Census7")
```
When we divide the age into 10 years,we found strong evidence for the $H_2$ that the age distribution from PSA001 is different from that of Census data, with $Log(BF_{10})$ = `r BF_h2b_age_psych_interval10$BF$LogBF10`.

When we divide age into stages of psychological development, we found strong evidence for the $H_2$ that the age distribution from PSA001 is different from that of Census data, with $Log(BF_{10})$ = `r BF_h2b_age_psych_interval_stages$BF$LogBF10`.

#### Age bins [set 2]: Psychological age bins

## Test H3: Chinese samples versus samples from other countries
We first select data for plotting.
```{r preproc data, message=FALSE, warning=FALSE}
### Get countries with n >=30
PSA001_valid_countries <-  df_PSA001 %>%
  dplyr::group_by(Countries) %>%
  dplyr::summarise(n = n()) %>%
  dplyr::ungroup() %>%
  dplyr::filter(n >=30 & !is.na(Countries)) %>%
  dplyr::pull(Countries)

### remove data without sex info
df_PSA001_valid_sex <-  df_PSA001 %>% 
  dplyr::filter(Countries %in% PSA001_valid_countries) %>%
  dplyr::mutate(Sex = ifelse(Sex == "no" | Sex == "na", NA, Sex))


df_PSA001_valid_merge <- merge(df_PSA001_valid_sex, df_regionCode, by.x = "Countries", by.y = "country_iso2")

df_PSA001_valid_merge_sex_ratio <- df_PSA001_valid_merge %>%
  dplyr::filter(!is.na(Sex)) %>%
  dplyr::count(weird, Countries, Sex) %>%
  dplyr::group_by(weird, Countries) %>%
  dplyr::mutate(Proportion = round(n / sum(n), 2)) %>%
  dplyr::arrange(Sex, Proportion) %>%
  dplyr::ungroup()

countries_order_sex <- df_PSA001_valid_merge_sex_ratio %>%
  dplyr::filter(Sex == "f") %>%
  dplyr::pull(Countries)

df_PSA001_valid_merge_sex_ratio_sorted <- df_PSA001_valid_merge_sex_ratio %>%
  dplyr::mutate(Countries = factor(Countries, levels = countries_order_sex))

df_PSA001_valid_merge_sex_ratio_sorted_wide <- df_PSA001_valid_merge_sex_ratio_sorted %>%
  dplyr::select(-c(weird,n)) %>%
  dplyr::mutate(Proportion = Proportion * 100)  %>%
  tidyr::pivot_wider(names_from = "Countries", values_from = "Proportion")
```

```{r define a function for calculating BF for multiple countries, message=FALSE, warning=FALSE}
# create a new variable to store the BF values
Func_BFpairs <- function(df, countries_order, prop_name){
  
  # create a temp variable for storing 
  BF_mult_tmp <- data.frame(matrix(nrow = 0, ncol = 8))
  colnames(BF_mult_tmp) <- c("Observed", "Expected", "Log(BF10)_NonInform", "BF10_NonInform", "BF01_NonInform", 
                                "Log(BF10)_Inform", "BF10_Inform", "BF01_Inform")

  for (ii in seq(length(countries_order))){
    country <- countries_order[ii]
    if (country != "CN"){
      df_tmp <- df %>% dplyr::select(prop_name, one_of(country), "CN")
      
      BF_tmp <- BayesMultiNomial(dataset = df_tmp, 
                                 factor = prop_name, observed = country, expected = "CN")
      BF_tmp2 <- BayesMultiNomial(dataset = df_tmp, 
                                 factor = prop_name, observed = country, expected = "CN", prior = "CN")
      
      BF_mult_tmp[ii,] <- c(country, "CN", BF_tmp$BF$LogBF10, BF_tmp$BF$BF10, BF_tmp$BF$BF01,
                           BF_tmp2$BF$LogBF10, BF_tmp2$BF$BF10, BF_tmp2$BF$BF01)
    } 
  }
  
  countries_order_age <- BF_mult_tmp %>% 
  tidyr::drop_na() %>%
  dplyr::mutate(`Log(BF10)_NonInform` = as.numeric(`Log(BF10)_NonInform`)) %>%
  dplyr::arrange(`Log(BF10)_NonInform`) %>%
  dplyr::pull(Observed)

  BF_mult_p_tmp <- BF_mult_tmp %>%
    tidyr::drop_na() %>%
    dplyr::select(1,2,3,6) %>%
    tidyr::pivot_longer(cols = `Log(BF10)_NonInform`:`Log(BF10)_Inform`, 
                        names_to = "Prior",
                        values_to = "Log(BF10)") %>%
    dplyr::mutate(Prior = stringr::str_remove(Prior, ".*_" )) %>%
    dplyr::mutate(Contries = factor(Observed, levels = countries_order_age),
                  Prior = factor(Prior, levels = c("NonInform", "Inform")),
                  `Log(BF10)` = as.numeric(`Log(BF10)`)) 

  return(BF_mult_p_tmp)
}
```

```{r Test H3a, message=FALSE, warning=FALSE}
# compare each country with CN, non-informative prior
BF_h3a_sex_p <- Func_BFpairs(df = df_PSA001_valid_merge_sex_ratio_sorted_wide,
                             countries_order = countries_order_sex,
                             prop_name = "Sex")

fig4a <- ggplot(BF_h3a_sex_p, aes( x = `Log(BF10)`, y = Contries, color = Prior )) +
  geom_point() +
  scale_color_grey() +
  xlim(-3, 21) +
  scale_y_discrete(limits=rev) +
  geom_vline(xintercept = c(log(1/10), log(1/6), 0, log(6), log(10)), 
             colour = c("red", "tomato", "black", "deepskyblue","blue"), 
             linetype=c("longdash", "longdash", "solid", "longdash","longdash")) + 
  geom_text(aes(x=log(10), label="\nStrong evidence for H1", y = 23), colour="blue", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(6), label="Moderate evidence for H1\n", y = 23), colour="deepskyblue", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(1/6), label="\nModerate evidence for H0", y = 23), colour="tomato", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(1/10), label="Strong evidence for H0\n", y = 23), colour="red", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  ggtitle("Sex ratio") + 
  theme_bw() +
        theme(panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.background = element_blank(),
              panel.border = element_blank(),
              text = element_text(family='Times'),
              legend.title = element_text(size =16),
              legend.text = element_text(size =14),
              axis.text.x = element_text (size = 14, color = 'black',  hjust = 1),
              axis.text.y = element_text (size = 16, color = 'black'),
              plot.title = element_text(lineheight=.8, face="bold", size = 18, margin=margin(0,0,20,0)),
              axis.text = element_text (size = 16, color = 'black'),
              axis.title = element_text (size = 16),
              axis.title.x = element_text (size = 16),
              axis.title.y = element_text( size = 16),
              axis.line.x = element_line(color='black', size = 1),
              axis.line.y = element_line(color='black', size = 1),
              strip.text = element_text (size = 16, color = 'black'), 
              panel.spacing = unit(3, "lines")
        )
#fig4a
```

Plot figure 4c, 
```{r figure 4c, message=FALSE, warning=FALSE}
fig4c <- ggplot(df_PSA001_valid_merge_sex_ratio_sorted, aes(x=Proportion, y=Countries,fill=Sex)) +
  geom_col(alpha = .75)+
  labs(y="Countries") + 
  scale_fill_discrete(label=c("female","male")) +
  theme_classic()+
  guides(y="axis_nested") +
  theme(legend.title = element_text(size = 15,family = "serif"),
        axis.title= element_text(size = 15,family = "serif"),
        axis.text = element_text(size = 10,family = "serif"),
        strip.text = element_text(size = 15,family = "serif"),
        strip.background = element_rect(fill = NA,color = NA),
        panel.border = element_rect(fill = NA,color = "black")) +
  scale_x_continuous(breaks = seq(0, 1, by = 0.1)) +
  facet_wrap(~ weird, scales = "free")
#fig4c
```
Get the percentage of each age bin and save for Bayesian multinomial test. We found that if the expected proportion contains zero if may cause problem in the calculation, thus, we re-organized the data based on the proportion data of Chinese sample.

```{r define a func for proportion of age bins, message=FALSE, warning=FALSE}
Func_Age_Prop <- function(df, break_names, label_names, wider_form=TRUE){
  #### function for calculating the proportion of age bins based on the break_names and label_names
  # df: the input data, with user_id, Countries, Sex, and Age
  # break_names, a vector of number
  # label_names, a vector of string
  #
  # return a wide-format data frame for further BF calculation
  ####
  
  df_tmp <- df %>%
    dplyr::select(user_id, Countries, Sex, Age) %>%
    dplyr::mutate(ageBins=cut(Age, 
                              breaks=break_names,  
                              labels=label_names)) %>%
    dplyr::count(Countries, ageBins) %>%
    dplyr::group_by(Countries) %>%
    dplyr::mutate(freq = (n / sum(n))*100) %>%
    dplyr::ungroup() %>%
    tidyr::complete(Countries, ageBins, fill = list(n = 0, freq = 0)) %>%
    dplyr::mutate(percent = floor(freq),
                  indx = freq - percent)
  
  ## below we fill the percentage to 100%
  filler_idx <- df_tmp %>%
    dplyr::group_by(Countries) %>%
    dplyr::summarise(sum = sum(percent)) %>%
    dplyr::ungroup() 

  df_tmp_filled <- data.frame(matrix(ncol = ncol(df_tmp), nrow = 0))
  colnames(df_tmp_filled) <- colnames(df_tmp)

  for (ii in 1:nrow(filler_idx)){
    tmp <- df_tmp %>% 
      dplyr::filter(Countries == filler_idx$Countries[ii]) %>%
      dplyr::arrange(desc(indx))
    
    if (filler_idx$sum[ii] < 100) {
      for (jj in seq(100 - filler_idx$sum[ii])){
       tmp$percent[jj] <- tmp$percent[jj] + 1
      }
    }
    df_tmp_filled <- rbind(df_tmp_filled, tmp)
  }
  df_tmp_filled <- df_tmp_filled %>%
    dplyr::arrange(Countries, ageBins)
  
  if (wider_form){
    df_tmp_filled <- df_tmp_filled %>%
      dplyr::select(-c(n, freq, indx)) %>%
      tidyr::pivot_wider(names_from = "Countries", values_from = "percent") 
  }
  
  
  return(df_tmp_filled)
}
```

```{r prepare data for test, message=FALSE, warning=FALSE}
df_PSA001_Age_valid <- df_PSA001 %>% 
  dplyr::filter(!is.na(Age)) %>%   
  dplyr::filter(Countries %in% PSA001_valid_countries) 

# merge with country code and force the age over 60 in a narrow range for visualization
df_PSA001_Age_valid_countryCode <- merge(df_PSA001_Age_valid, df_regionCode, by.x = "Countries", by.y = "country_iso2") %>%
  dplyr::mutate(Age = ifelse(Age > 60, sample(c(61, 62, 63, 64, 65), 1), Age))

PSA001_valid_countries_sorted <- df_PSA001_Age_valid_countryCode %>%
  dplyr::group_by(Countries) %>%
  dplyr::summarise(medianAge = median(Age)) %>%
  dplyr::ungroup() %>%
  dplyr::arrange(medianAge) %>%
  dplyr::pull(Countries)

df_PSA001_Age_valid_countryCode_sorted <- df_PSA001_Age_valid_countryCode %>%
  dplyr::mutate(Countries = factor(Countries, levels = PSA001_valid_countries_sorted)) %>%
  dplyr::filter(!(Sex=="no" | Sex=="na"))

# age bin same as census data
df_PSA001_age_Jasp1 <- Func_Age_Prop(df = df_PSA001_Age_valid_countryCode_sorted,
                                     break_names = c(0, 10.5, 20.5, 30.5, 40.5, 50.5, 60.5, Inf),
                                     label_names = c("0~10","11~20","21~30", "31~40", "41~50", "51~60", ">=61"))

df_PSA001_age_Jasp1 <- df_PSA001_age_Jasp1 %>%
  # fill zero
  dplyr::mutate(CN = ifelse(CN==0, 1,
                            ifelse(CN==38, 37, 
                                   ifelse(CN  == 55, 54, CN))))

# age bin based on psychological aging stage
df_PSA001_age_Jasp2 <- Func_Age_Prop(df = df_PSA001_Age_valid_countryCode_sorted,
                                     break_names = c(0, 17.5, 25.5, 39.5, 59.5, Inf),
                                     label_names = c("0~17","18~25", "26~40", "41~59", ">=60"))

df_PSA001_age_Jasp2 <- df_PSA001_age_Jasp2 %>%
  # fill zero
  dplyr::mutate(CN = ifelse(CN==0, 1, 
                            ifelse(CN==80, 78, CN)))

df_PSA001_age_Jasp2_long <- Func_Age_Prop(df = df_PSA001_Age_valid_countryCode_sorted,
                                     break_names = c(0, 17.5, 25.5, 39.5, 59.5, Inf),
                                     label_names = c("0~17","18~25", "26~40", "41~59", ">=60"),
                                     wider_form = FALSE) %>%
  dplyr::left_join(., df_regionCode, by = c("Countries" = "country_iso2")) %>%
  dplyr::mutate(Proportion = percent/100)

# Countries order for plotting age bins proportions
df_PSA001_age_Jasp2_long_countries <- df_PSA001_age_Jasp2_long %>%
  dplyr::filter(ageBins == "18~25") %>%
  dplyr::arrange(Proportion) %>%
  dplyr::pull(Countries)

df_PSA001_age_Jasp2_long <- df_PSA001_age_Jasp2_long %>%
  dplyr::mutate(Countries = factor(Countries, levels = df_PSA001_age_Jasp2_long_countries))

```

```{r preproc for age, message=FALSE, warning=FALSE}
fig4d <- ggplot(df_PSA001_age_Jasp2_long, aes(x=Proportion, y=Countries, fill=ageBins)) +
  geom_col(alpha = .75)+
  labs(y="Countries") + 
  scale_fill_discrete(label=c("0~17", "18~25", "26~40", "41~59",">=60" )) +
  theme_classic()+
  guides(y="axis_nested") +
  theme(legend.title = element_text(size = 15,family = "serif"),
        axis.title= element_text(size = 15,family = "serif"),
        axis.text = element_text(size = 10,family = "serif"),
        strip.text = element_text(size = 15,family = "serif"),
        strip.background = element_rect(fill = NA,color = NA),
        panel.border = element_rect(fill = NA,color = "black")) +
  scale_x_continuous(breaks = seq(0, 1, by = 0.1)) +
  facet_wrap(~ weird, scales = "free")
#fig4d
```

```{r Test H3b,message=FALSE, warning=FALSE}
# BF for age bins 0, NA for informed prior because of zeros in the dataframe
BF_h3b_age_p_1 <- Func_BFpairs(df = df_PSA001_age_Jasp1, 
                             countries_order = countries_order_sex,
                             prop_name = "ageBins")

# BF for age bins 2
BF_h3b_age_p_2 <- Func_BFpairs(df = df_PSA001_age_Jasp2, 
                             countries_order = countries_order_sex,
                             prop_name = "ageBins")

fig4b <- ggplot(BF_h3b_age_p_2, aes( x = `Log(BF10)`, y = Contries, color = Prior )) +
  geom_point() +
  scale_color_grey() +
  xlim(-10, 60) +
  scale_y_discrete(limits=rev) +
  geom_vline(xintercept = c(log(1/10), log(1/6), 0, log(6), log(10)), 
             colour = c("red", "tomato", "black", "deepskyblue","blue"), 
             linetype=c("longdash", "longdash", "solid", "longdash","longdash")) + 
  geom_text(aes(x=log(10), label="\nStrong evidence for H1", y = 23), colour="blue", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(6), label="Moderate evidence for H1\n", y = 23), colour="deepskyblue", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(1/6), label="\nModerate evidence for H0", y = 23), colour="tomato", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(1/10), label="Strong evidence for H0\n", y = 23), colour="red", alpha = 0.7, 
            angle=90, text=element_text(size=10))  +
  ggtitle("Age distribution") +
  theme_bw() +
        theme(panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.background = element_blank(),
              panel.border = element_blank(),
              text = element_text(family='Times'),
              legend.title = element_text(size =16),
              legend.text = element_text(size =14),
              axis.text.x = element_text (size = 14, color = 'black',  hjust = 1),
              axis.text.y = element_text (size = 16, color = 'black'),
              plot.title = element_text(lineheight=.8, face="bold", size = 18, margin=margin(0,0,20,0)),
              axis.text = element_text (size = 16, color = 'black'),
              axis.title = element_text (size = 16),
              axis.title.x = element_text (size = 16),
              axis.title.y = element_text( size = 16),
              axis.line.x = element_line(color='black', size = 1),    
              axis.line.y = element_line(color='black', size = 1),    
              strip.text = element_text (size = 16, color = 'black'), 
              panel.spacing = unit(3, "lines")
        )
#fig4b
p_BF <- (fig4a + fig4b) /
   (fig4c + fig4d) +
  plot_annotation(tag_levels = 'A')  & 
  theme(plot.tag = element_text(size = 18, face = "bold"))

ggsave("Fig4_withBF.pdf", p_BF, device = "pdf", width=18, height = 18)
p_BF
```
```{r Plot using age groups similar to the age bins of census. See supplementary materials for this section, message=FALSE, warning=FALSE}

df_PSA001_age_Jasp1_long <- Func_Age_Prop(df = df_PSA001_Age_valid_countryCode_sorted,
                                     break_names = c(0, 10.5, 20.5, 30.5, 40.5, 50.5, 60.5, Inf),
                                     label_names = c("0~10","11~20","21~30", "31~40", "41~50", "51~60", ">=61"),
                                     wider_form = FALSE) %>%
  dplyr::left_join(., df_regionCode, by = c("Countries" = "country_iso2")) %>%
  dplyr::mutate(Proportion = percent/100)

# Countries order for ploting age bins proprotions
df_PSA001_age_Jasp1_long_countries <- df_PSA001_age_Jasp1_long %>%
  dplyr::filter(ageBins == "0~10") %>%
  dplyr::arrange(Proportion) %>%
  dplyr::pull(Countries)

df_PSA001_age_Jasp1_long <- df_PSA001_age_Jasp1_long %>%
  dplyr::mutate(Countries = factor(Countries, levels = df_PSA001_age_Jasp1_long_countries))


S1b <- ggplot(df_PSA001_age_Jasp1_long, aes(x=Proportion, y=Countries, fill=ageBins)) +
  geom_col(alpha = .75)+
  labs(y="Countries") + 
  scale_fill_discrete(label=c("0~10","11~20","21~30", "31~40", "41~50", "51~60", ">=61")) +
  theme_classic()+
  guides(y="axis_nested") +
  theme(legend.title = element_text(size = 15,family = "serif"),
        axis.title= element_text(size = 15,family = "serif"),
        axis.text = element_text(size = 10,family = "serif"),
        strip.text = element_text(size = 15,family = "serif"),
        strip.background = element_rect(fill = NA,color = NA),
        panel.border = element_rect(fill = NA,color = "black")) +
  scale_x_continuous(breaks = seq(0, 1, by = 0.1)) +
  facet_wrap(~ weird, scales = "free")
#S1b


S1a <- ggplot(BF_h3b_age_p_1, aes( x = `Log(BF10)`, y = Contries, color = Prior )) +
  geom_point() +
  scale_color_grey() +
  xlim(-15, 60) +
  scale_y_discrete(limits=rev) +
  geom_vline(xintercept = c(log(1/10), log(1/6), 0, log(6), log(10)), 
             colour = c("red", "tomato", "black", "deepskyblue","blue"), 
             linetype=c("longdash", "longdash", "solid", "longdash","longdash")) + 
  geom_text(aes(x=log(10), label="\nStrong evidence for H1", y = 23), colour="blue", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(6), label="Moderate evidence for H1\n", y = 23), colour="deepskyblue", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(1/6), label="\nModerate evidence for H0", y = 23), colour="tomato", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(1/10), label="Strong evidence for H0\n", y = 23), colour="red", alpha = 0.7, 
            angle=90, text=element_text(size=10))  +
  ggtitle("Age distribution") +
  theme_bw() +
        theme(panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.background = element_blank(),
              panel.border = element_blank(),
              text = element_text(family='Times'),
              legend.title = element_text(size =16),
              legend.text = element_text(size =14),
              axis.text.x = element_text (size = 14, color = 'black',  hjust = 1),
              axis.text.y = element_text (size = 16, color = 'black'),
              plot.title = element_text(lineheight=.8, face="bold", size = 18, margin=margin(0,0,20,0)),
              axis.text = element_text (size = 16, color = 'black'),
              axis.title = element_text (size = 16),
              axis.title.x = element_text (size = 16),
              axis.title.y = element_text( size = 16),
              axis.line.x = element_line(color='black', size = 1),    
              axis.line.y = element_line(color='black', size = 1),    
              strip.text = element_text (size = 16, color = 'black'), 
              panel.spacing = unit(3, "lines"))
#S1a
p_BF_supp <- S1a + S1b +
  plot_layout(tag_level = 'new') +
  plot_annotation(tag_levels =list(c("S1a","S1b")))  & 
  theme(plot.tag = element_text(size = 18, face = "bold"))

ggsave("Fig4_withBF_supp.pdf", p_BF_supp, device = "pdf", width=18, height = 9)
p_BF_supp
```
