---
title: Notebook for  Data Analyses of Chinese Samples in Psychological Subjects [Stage
  1 RR]
author: "Lei Yue (NNU, CCNU); Hu Chuan-Peng (NNU; hcp4715@hotmail.com)"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

This is an [R Markdown](http://rmarkdown.rstudio.com) file for data analyses in the protocol of a meta research which aims at surveying sample characteristics of Chinese sample in Chinese Psychological research. 

In this script, we will use data from PSA 001 project [Jones et al., 2021, *Nature Human Behavior*](https://doi.org/10.1038/s41562-020-01007-2) to exemplify the analyses that we are going to use in our this project.

First, load libraries.

```{r Initialization, message=FALSE, warning=FALSE, include=FALSE}
# rm(list = ls())
if (!require("pacman")) install.packages("pacman")

pacman::p_load("tidyverse", "ggh4x","stringr", "patchwork", "BayesFactor", "gtools", "bruceR")

options(scipen=999) 
```

# Bayesian multinomial test

## Background

We decided to use Bayesian multinomial test because it suits our purpose well: it can be used to test whether observed proportions (sex, or age bins, etc) is sample from the population with certain proportion values (e.g., census data). In Frequentists' framework, this can be done by $\chi^2$ test (goodness-of-fit).

Bayesian multinomial test can be done in JASP and a short introduction can be found here: Goss-Sampson, M. (2020, May 17). New Bayesian guide. https://doi.org/10.17605/OSF.IO/CKNXM. 

The function implemented in JASP can be found [here](https://github.com/jasp-stats/jaspFrequencies/blob/d48babf63b14526abaf2c208c8ae769801b6d4db/R/multinomialtestbayesian.R#L384). 

A more detailed explanation for Bayesian multinomial test can be found in ([Sarafoglou et al., 2020](https://doi.org/10.31234/osf.io/bux7p), part 1). Here we also explain it below. 

## How does the JASP's multinomial work?

Essentially, the algorithm in JASP used Savage-Dickey likelihood ratio ([Wagenmakers 2010, Cognitive Psychology](https://doi.org/10.1016/j.cogpsych.2009.12.001)) to calculate the BF. That is the likelihood of a point given the prior distribution and the likelihood of that same point given the posterior distribution. 

Because multinomial distribution has nice conjugate prior, the Dirichlet distribution, the calculation of posterior of multinomial distribution does not requires MCMC. It is important to be clear about the following issues:
* What is the prior (the distribution of all possible parameters of multinomial).
* How to calculate the likelihood of the under the prior.
* How posterior is updated.
* How to calculate the likelihood under the posterior (which should be easy if the second question is known)

Answering these questions need dive into the mulitnomial distribution itself.

### Multinomial distribution & Dirichlet distribution

The multinomial distribution is a generalization of the binomial distribution, see [here more](https://en.wikipedia.org/wiki/Multinomial_distribution). 

The probability mass function (PMF) of multinomial distribution is:

$$f(x_1, ..., x_k; n, p_1, ..., p_n) = Pr(X_1 = x_1 \, and \, ...  \, and \, X_k = x_k) = \frac{n!}{x_1! ... x_n!} p_1^{x_1} \times ... \times p_k^{x_k}$$
where $\sum_{i=1}^{k}{x_i=n}$, for non-negative integers $x_1, ..., x_k$

This PMF can be expressed using the gamma function as:

$$f(x_1, ..., x_k; n, p_1, ..., p_n) = \frac{\Gamma(\sum_{i}{x_i +1})}{\prod_{i}\Gamma(x_i + 1)} \prod_{i=1}^{k} p_{i}^{x_i}$$

The distribution of **parameters** of multinomial distribution $\theta = (\theta_1, \theta_2, ..., \theta_K)$ is a Dirichlet distribution with concentration parameters ($\alpha_1$, $\alpha_2$, ..., $\alpha_k$, where $\alpha > 0$:

$$p(\theta) = p(\theta_1, \theta_2, ..., \theta_k) = \frac {\Gamma(\sum_{k=1}^k \alpha_k)} {\sum_{k=1}^k\Gamma (\alpha_k)} \prod_{k=1}^k \theta_k^{\alpha_{k}-1} = \frac {1} {B(\alpha)} \prod_{k=1}^k \theta_k^{\alpha_{k}-1} $$

The posterior distribution of **parameters** of multinomial distribution also follows Dirichlet distribution:

$$p(\theta | x) = \frac {\Gamma(N + \sum_{k=1}^k \alpha_k)} {\sum_{k=1}^k\Gamma (x_k + \alpha_k)} \prod_{k=1}^k \theta_k^{x_k + \alpha_{k}-1} = \frac {1} {B(\alpha + x)} \prod_{k=1}^k \theta_k^{x+k + \alpha_{k}-1} $$

Usually, $H_0$ is a point null hypothesis, which is often specified as all parameters are equal. The alternative hypothesis, $H_a$, or $H_e$ in [Sarafoglou et al., 2020](https://doi.org/10.31234/osf.io/bux7p), is a distribution, which states that all category proportions are free to vary without any ordinal restriction. 

### BF for multinomial test

Because $H_0$ is a point null hypothesis, the $BF_{0e}$ can be calculated using Savage-Dickey Ratio:

$$BF_{0e} = \frac {p(x | H_0)}{p(x | H_e)}  = \frac {p(x | \theta = c, H_e)}{\frac {p(x | \theta = c, H_e) p(\theta = c | H_e)} {p(\theta = c | x, H_e)}} = \frac {p(\theta = c \, | \, x, He)} {p(\theta = c \, | \, He)} $$

"The underlying principle of the Savage-Dickey density ratio is to compute the Bayes factor by dividing the height of the posterior density under $H_e$ at the point of interest (i.e., $c$) by the height of the prior density under $H_e$ at the same point."

Here prior, ($\alpha_1, ...$), is the parameters of Dirichlet distribution $Dir(\alpha_1, \alpha_2, ..., \alpha_k)$, which is not equal to $c$. $c$ is a point in the space that defined by Dirichlet distribution. The parameter $(\alpha_1 = 1, \alpha_1 = 2, ..., \alpha_K = 1)$ of Dirichlet distribution means that $c$ is equally possible with other set of $\theta$.

To understand the Dirichlet distribution and it's parameters, please see [here](https://en.wikipedia.org/wiki/Dirichlet_distribution).


Using the prior and posterior distribution of Dirichlet, we can directly calculated the $BF_{0e}$

$$BF_{0e} = \frac {p(\theta = c \, | \, x, H_e)} {p(\theta = c \, | \, H_e)} =  \frac {1} {B(x+\alpha)} \prod_{k=1}^k \theta_k^{x_k + \alpha_{k}-1} / \frac {1} {B(\alpha)} \prod_{k=1}^k \theta_k^{\alpha_{k}-1} $$
$$BF_{0e} = \frac {p(\theta = c \, | \, x, H_e)} {p(\theta = c \, | \, H_e)} = \frac {Beta(\alpha)} {Beta(x + \alpha)} * \frac {\prod_{k=1}^k \theta_k^{x_k + \alpha_{k}-1}} {\prod_{k=1}^k \theta_k^{\alpha_{k}-1}}$$

$$BF_{e0} = 1/BF_{0e} = \frac {Beta(x + \alpha)} {Beta( \alpha)} * \frac {\prod_{k=1}^k \theta_k^{\alpha_{k}-1}} {\prod_{k=1}^k \theta_k^{x_k + \alpha_{k}-1}} $$
The above is the formula for the analytically solution of BF in R.

$$ log(BF_{e0}) = log(Beta(x + \alpha))- log(Beta( \alpha)) + (\sum_{k=1}^k log(\theta_k *(\alpha_{k}-1)) - \sum_{k=1}^k log(\theta_k * (x_k + \alpha_{k}-1))) $$

$$ log(BF_{e0}) = log(Beta(x + \alpha))- log(Beta( \alpha)) + (\sum_{k=1}^k log(\theta_k *(\alpha_{k}-1)) - (\sum_{k=1}^k log(\theta_k * x_k) +  \sum_{k=1}^k log(\theta_k * (\alpha_{k}-1)))) = log(Beta(x + \alpha))- log(Beta( \alpha)) - \sum_{k=1}^k log(\theta_k * x_k) $$

### Algorithm in R

```
lbeta.xa <- sum(lgamma(alphas + counts)) - lgamma(sum(alphas + counts))
lbeta.a  <- sum(lgamma(alphas)) - lgamma(sum(alphas))

LogBF10 <- (lbeta.xa-lbeta.a) + (0 - sum(counts * log(thetas)))  
```

Here, `alphas` defined the prior Dirichlet distribution, e.g., noninformative prior is a vector of $1$s, `counts` are the observed frequencies.

To use the algorithm in R, we defined a function here:

```{r define BF for Multinomial test, message=FALSE, warning=FALSE}
BayesMultiNomial <- function(dataset, factor, observed, expected, default_prior = TRUE, prior = NA){
  # datase - the input dataframe
  # factor - column name of the factor,
  # observed - column name of the column contains counts information for the observed,
  # expected - column name of the column contains counts information for the expected,
  # default_prior - whether use the default, defused prior
  # prior - priors defined by users
  
  fact_level <- dataset %>% dplyr::select(all_of(factor)) %>% dplyr::pull()
  observed_data <- dataset %>% dplyr::select(all_of(observed)) %>% dplyr::pull()
  names(observed_data) <- fact_level
  expected_data <- dataset %>% dplyr::select(all_of(expected)) %>% dplyr::pull()
  n_levels <- length(observed_data)
  
  
  if (default_prior & all(is.na(prior))) {
    prior <- rep(1, n_levels)
  } else{
    if (is.character(prior)){
      prior <- dataset %>% dplyr::select(all_of(prior)) %>% dplyr::pull()
    } else if (is.array(prior)){
      prior <-  prior
    } else if (is.numeric(prior)){
      prior <-  prior
    } else{
      print("prior much a column of the input data or a vector")
    }
  }
  
  alphas <- prior
  counts <- observed_data
  thetas <- expected_data
  
  if(sum(thetas) != 1) {
    thetas <- thetas/sum(thetas)
    }
  
  expected <- setNames(sum(counts)*thetas, names(counts))
  
  lbeta.xa <- sum(lgamma(alphas + counts)) - lgamma(sum(alphas + counts))
  lbeta.a  <- sum(lgamma(alphas)) - lgamma(sum(alphas))

  if (any(rowSums(cbind(thetas, counts)) == 0)) {
    LogBF10 <- (lbeta.xa-lbeta.a)
  } else {
    LogBF10 <- (lbeta.xa-lbeta.a) + (0 - sum(counts * log(thetas))) 
  }

  BF <- data.frame(LogBF10 = LogBF10,
                   BF10    = exp(LogBF10),
                   BF01    = 1/exp(LogBF10))

  return(list(BF       = BF,
              expected = expected))
  
}
```

### Justification for the Bayesian multinomial test

To test whether the current non-informative prior is reasonable, we conducted a simulation to test the sensitivity.

We tested the false positive rate of the current setting and false negative (power = 1 - FN ) of the current setting under different deviation from the expected. 

#### Test the default prior for sex ratio

For sex ratio, we used the $Y \sim Binomial(p = 0.5)$ as the null model, any deviation from $0.5$ will be viewed as different from the null effect. 

**False Positive Rate**: The proportion of $BF_{01}$ that greater than 3.

**Power**: The proportion of $BF_{01}$ that greater than 3.


As the $H_1$ is any deviation from the null, we need to get a reasonable smallest effect size of interest. We used data from [Rad et al., 2018](https://www.pnas.org/content/115/45/11401) for this purpose.

In this paper, Rad et al. surveyed papers published in *Psychological Science* on how the demographic information reported in these papers. In the supplementary, they provided 35 studies, which can be identified and their participants' sex ratio can be found. We used these data as our basis of smallest effect size of interest.

```{r smallest effect size of interest}
df_rad2018 <- read.csv("Rad_2018_suppl.csv") %>%
  dplyr::mutate(male_num = as.numeric(male_num),
                female_num = as.numeric(female_num)) %>%
  dplyr::filter(!is.na(male_num)) %>%
  dplyr::select(1:2, 13:14) %>%
  dplyr::mutate(prop = male_num/(male_num + female_num),
                deviation = prop - 0.5,
                dev_abs = abs(deviation)) %>%
  dplyr::arrange(dev_abs)

effect_size <- bootES::bootES(df_rad2018$dev_abs, plot=TRUE)

```


We found that the mean deviation from 0.5, estimated by `bootES`, is 0.085, 95% CI[0.061 0.115]. Following the practices of previous study [reference is needed], we decided to used the lower boundary of this CI, 0.06 as the smallest effect size of interest. 

```{r define function for testing sex ratio, message=TRUE, warning=FALSE}
# define a function to run the simulation for sex ratio
Sim_Power_binormial <- function(seed = 12345, sim_N = 1000, ss = 100, effect = 0, nil_effect = 0.5, prior = 1){
  
  # seed: the seed for randomization
  # sim_N: number of simulation
  # ss: sample size in the simulation
  # effect: deviation from null
  # nil_effect: null effect
  
  set.seed(seed)
  
  sim_1 <- data.frame(obs = rbinom(sim_N, size = ss, prob = nil_effect + effect ))
  sim_1$sex <- "male"
  sim_1$iter <- seq(sim_N)
  sim_2 <- data.frame(obs = ss - sim_1$obs)
  sim_2$sex <- "female"
  sim_2$iter <- seq(sim_N)
  
  sim <- sim_1 %>% 
    dplyr::bind_rows(., sim_2) %>% 
    dplyr::arrange(iter)
  
  test_BF <- data.frame(matrix(nrow = sim_N, ncol = 3))
  colnames(test_BF) <- c("Iter", "1st_prop", "BF10")
  
  for (ii in seq(sim_N)){
    test_df <- sim %>%
      dplyr::filter(iter == ii) %>%
      dplyr::mutate(expected = nil_effect * ss)
    
    # test_df1$obs <- c(test_df1$expected[1] - ii, test_df1$expected[2] + ii)
    tmp_BF <- BayesMultiNomial(test_df, factor = 'sex', observed = 'obs', 
                               expected = 'expected', 
                               prior = rep(prior, 2))
    test_BF$Iter[ii] <- ii
    test_BF$`1st_prop`[ii] <- test_df$expected[1] - ii
    # test_BF$`log_BF10`[ii] <- tmp_BF$BF$LogBF10
    test_BF$`BF10`[ii] <- tmp_BF$BF$BF10
    
  }
  
  BF_power <- data.frame(matrix(nrow = 1, ncol = 6))
  colnames(BF_power) <- c("Category", "Prob", "Prior","Sample_Size", "BF_3", "BF_6")
  
  if (effect == 0) {
    BF_power$Prob <- nil_effect + effect
    BF_power$Sample_Size <- ss
    BF_power$Prior <- prior
    BF_power$Category <- "BF01"
    # BF_power$BF_1 <- sum(test_BF$BF10 < 1)/1000 
    BF_power$BF_3 <- sum(test_BF$BF10 <= 1/3)/1000 
    BF_power$BF_6 <- sum(test_BF$BF10 <= 1/6)/1000 
  } else {
    BF_power$Prob <- nil_effect + effect
    BF_power$Category <- "BF10"
    BF_power$Sample_Size <- ss
    BF_power$Prior <- prior
    # BF_power$BF_1 <- sum(test_BF$BF10 > 1)/1000 
    BF_power$BF_3 <- sum(test_BF$BF10 >= 3)/1000 
    BF_power$BF_6 <- sum(test_BF$BF10 >= 6)/1000 
  }
  return(BF_power)
}

### false positive rate
Sim_False_Pos_Binom <- Sim_Power_binormial()

```

```{r test default prior with varying N, message=TRUE, warning=FALSE}
### simulation for Power
SESOI <- 0.06
Sample_sizes <- seq(100, 1500, 100) # create a sequence from 100 to 2000, with 500 step size.

Sample_sizes <- c(Sample_sizes, 1000)

# iterate each of theses probabilities and save the percentage of BF10 >=3, BF10 >=60
rm(res_bf_binom)  # remove variable with name "res_bf_power_binom" to avoid error
for (jj in (seq(length(Sample_sizes)))){
  tmp_power  <- Sim_Power_binormial(seed = 1000, ss = Sample_sizes[jj], effect = 0.06)
  tmp_falpos <- Sim_Power_binormial(seed = 1000, ss = Sample_sizes[jj], effect = 0)
  if (exists("res_bf_binom")){
    res_bf_binom <- rbind(res_bf_binom, tmp_power,tmp_falpos)
  } else {
    res_bf_binom <- rbind(tmp_power,tmp_falpos)
  }
}

res_bf_binom <- res_bf_binom %>% 
  dplyr::arrange(Category, Sample_Size)

# plot the results
p_sim1 <- res_bf_binom %>%
  ggplot2::ggplot(., aes(x = Sample_Size, y = BF_6, color=Category)) +
  ggplot2::geom_point() + 
  ggplot2::geom_hline(yintercept = 0.8) +
  ggplot2::theme_classic()

ggsave("p_sim1.png", p_sim1, width = 8, height = 5)
```

```{r test default prior with varying prior, message=TRUE, warning=FALSE}
### simulation for Power
SESOI <- 0.06
priors <- seq(0.1, 1, 0.1) # create a sequence from 100 to 2000, with 500 step size.
priors <- c(priors, c(1, 1.5, 2, 2.5, 3))
# iterate each of theses probabilities and save the percentage of BF10 >=3, BF10 >=60
rm(res_bf_binom_prior)  # remove variable with name "res_bf_power_binom" to avoid error
for (jj in (seq(length(priors)))){
  tmp_power  <- Sim_Power_binormial(seed = 1000, ss = 100, effect = 0.06, prior = priors[jj])
  tmp_falpos <- Sim_Power_binormial(seed = 1000, ss = 100, effect = 0, prior = priors[jj])
  if (exists("res_bf_binom_prior")){
    res_bf_binom_prior <- rbind(res_bf_binom_prior, tmp_power,tmp_falpos)
  } else {
    res_bf_binom_prior <- rbind(tmp_power,tmp_falpos)
  }
}

res_bf_binom_prior <- res_bf_binom_prior %>% 
  dplyr::arrange(Category, Prior)

# plot the results
p_sim2 <- res_bf_binom_prior %>% 
  dplyr::arrange(Category, Prior) %>%
  ggplot2::ggplot(., aes(x = Prior, y = BF_6, color=Category)) +
  ggplot2::geom_point() + 
  ggplot2::geom_hline(yintercept = 0.8) +
  ggplot2::theme_classic()

# save the plot
p_sim <- p_sim1 + p_sim2 +
  plot_layout(guides = 'collect') + plot_annotation(tag_levels = 'A')

ggsave("p_sim.png", p_sim, width = 10, height = 4)
```

Our simulation found that, for sex ratio, the current setting (prior), we can have detect deviation from p = 0.5 with more 80% of the times if the difference is greater than 0.17.

#### Test the default prior for age bins

Warnings: run the code chunk below line-by-line, it include a time-consuming for-loop.

```{r test default prior for age ratio, message=FALSE, warning=FALSE}
Sim_Power_mult_calc <- function(seed = 12345, 
                           sim_N = 5000,             # set to 5000 for real simulation
                           sample_N = 1200,
                           sim_prob = c(0.2, 0.2, 0.2, 0.2, 0.2), 
                           nil_effect = c(0.2, 0.2, 0.2, 0.2, 0.2)){
  library(tidyverse)
  
  set.seed(seed)

  tmp_data <- data.frame(rmultinom(n=sim_N, size=sample_N, prob = sim_prob))

  test_BF <- data.frame(matrix(nrow = sim_N, ncol = 2))
  colnames(test_BF) <- c("Iter", "BF10")
  for (ii in seq(sim_N)){
      sim_data1 <- tmp_data[, ii]
      sim_data2 <- nil_effect * sample_N
      test_df <- data.frame(expected = sim_data2,
                            obs = sim_data1)%>%
        dplyr::mutate(ageBins = paste0('bin', seq(5)))
      
      tmp_BF <- BayesMultiNomial(test_df, 
                                 factor = 'ageBins', 
                                 observed = 'obs', 
                                 expected = 'expected')
      test_BF$Iter[ii] <- ii
      test_BF$`BF10`[ii] <- tmp_BF$BF$BF10
      
  }
  
  BF_power <- data.frame(matrix(nrow = 1, ncol = 5))
  colnames(BF_power) <- c("Prob", "Category", "Sample_Size", "BF_3", "BF_6")
  
  BF_power$Prob <- paste0(round(sim_prob, 3), collapse = ';')
  
  if (sum(sim_prob == nil_effect)==length(sim_prob)) {
    
    BF_power$Category <- "Evidence_for_Null"
    BF_power$Sample_Size <- sample_N
    BF_power$BF_3 <- sum(test_BF$BF10 <= 1/3)/sim_N 
    BF_power$BF_6 <- sum(test_BF$BF10 <= 1/ 6)/sim_N 
  } else {
    BF_power$Category <- "Evidence_for_Effect"
    BF_power$Sample_Size <- sample_N
    BF_power$BF_3 <- sum(test_BF$BF10 >= 3)/sim_N 
    BF_power$BF_6 <- sum(test_BF$BF10 >= 6)/sim_N 
  }
  return(BF_power)
}

### false positive rate for this case
Sim_False_Pos_mult <- Sim_Power_mult_calc(sim_N = 5000)

Sim_Power_mult <- function(seed = 12345, 
                           sim_N = 1000,        # number of simulations for each multinomial prob vector, default: 1000
                           sim_N_probs = 5000,  # number of multinomial prob vectors, default is 5000 
                           sample_N = 1200,
                           sim_alpha = 1){
  set.seed(seed)
  
  sim_probs <- data.frame(gtools::rdirichlet(n = sim_N_probs, alpha = rep(sim_alpha, 5)))
  colnames(sim_probs) <- paste0("bin", seq(5))
  
  # using apply?
  # tmp <- apply(sim_probs, 1, function(x) Sim_Power_mult_calc(sim_prob = x))
  
  rm('res_bf_power_mult')
  for (jj in (seq(nrow(sim_probs)))){ 
    tmp_power <- Sim_Power_mult_calc(sim_prob = sim_probs[jj, 1:5],
                                     sim_N = sim_N,
                                     sample_N = sample_N,
                                     nil_effect = c(0.2, 0.2, 0.2, 0.2, 0.2))
    
    tmp_power$sim_alpha <- sim_alpha
    if (exists("res_bf_power_mult")){
      res_bf_power_mult <- rbind(res_bf_power_mult, tmp_power)
    } else {
      res_bf_power_mult <- tmp_power
    }
  }
  return(res_bf_power_mult)
}

# Test the function "Sim_Power_mult" with 50 times, and alpha for Dirichlet distribution as a vector of 10s
startTime <- Sys.time()
test <- Sim_Power_mult(sim_N = 50, sim_N_probs = 50, sim_alpha = 1)
endTime <- Sys.time()
print(endTime - startTime) # 19 sec

# If the above test is successful, then run the following code, using the default setting of "Sim_Power_mult", i.e., 10000 probabilities for each.

# alpha vector of Dirichlet, and 5000 multinomial vector for each probability, which means 10000 * 5000 iterations, it will take a few hours.

startTime <- Sys.time()
rm('Res_Sim_Multi')
Res_Sim_Multi <- Sim_Power_mult()
endTime <- Sys.time()
print(endTime - startTime) # approximately 9 hourse

# for (sim_alpha in c(1,2,3)){
#   # to quickly test the function, set sim_N = 5, sim_N_probs = 10
#   Sim_res_tmp <-  Sim_Power_mult(sim_N = 5000, 
#                                  sim_N_probs = 10000,
#                                  sim_alpha = sim_alpha)
# 
#   if (exists("Res_Sim_Multi")){
#       Res_Sim_Multi <- rbind(Res_Sim_Multi, Sim_res_tmp)
#     } else {
#       Res_Sim_Multi <- Sim_res_tmp
#     }
#   
# }

Res_Sim_Multi <- Res_Sim_Multi %>%
  dplyr::arrange(sim_alpha, BF_6)

Res_Power <- Res_Sim_Multi %>%
  dplyr::group_by(sim_alpha) %>%
  dplyr::filter(BF_3 >=0.8) %>%
  dplyr::summarise(n = n()/(nrow(Res_Sim_Multi)/length(unique(Res_Sim_Multi$sim_alpha))))

Res_Sim_Multi %>% 
  dplyr::group_by(sim_alpha) %>%
  dplyr::mutate(Iter = seq(n())) %>%
  dplyr::ungroup() %>%
  ggplot2::ggplot(., aes(x = Iter, y = BF_3, group = sim_alpha)) +
  ggplot2::geom_point(aes(color = as.factor(sim_alpha))) + 
  ggplot2::geom_hline(yintercept = 0.8) +
  ggplot2::theme_classic()
```

# foreach
```{r foreach package}
library(iterators)
library(foreach)
library(parallel)
library(doParallel)
```

```{r foreach function}
Sim_Power_mult_mt <- function(seed = 12345, 
                              sim_N = 5000,
                              # number of simulations for each multinomial prob vector, default: 1000
                              sim_N_probs = 5000,
                              # number of multinomial prob vectors, default is 5000 
                              sample_N = 1200,
                              sim_alpha = 1){
  
  # Query the total number of threads
  cl <- makeCluster(detectCores())
  registerDoParallel(cl)
  
  sim_probs <- data.frame(gtools::rdirichlet(n = sim_N_probs, alpha = rep(sim_alpha, 5)))
  colnames(sim_probs) <- paste0("bin", seq(5))
  
  # foreach
  res_bf_power_mult <- foreach(jj = seq(nrow(sim_probs)), .combine = rbind) %dopar% {
    
    set.seed(12345 + jj) # seed must be inside foreach
    
    #######################Function must be defined inside foreach#######################
    BayesMultiNomial <- function(dataset, factor, observed, expected, 
                                 default_prior = TRUE, prior = NA){
        # datase - the input dataframe
        # factor - column name of the factor,
        # observed - column name of the column contains counts information for the observed,
        # expected - column name of the column contains counts information for the expected,
        # default_prior - whether use the default, defused prior
        # prior - priors defined by users
        
        fact_level <- dataset %>% dplyr::select(all_of(factor)) %>% dplyr::pull()
        observed_data <- dataset %>% dplyr::select(all_of(observed)) %>% dplyr::pull()
        names(observed_data) <- fact_level
        expected_data <- dataset %>% dplyr::select(all_of(expected)) %>% dplyr::pull()
        n_levels <- length(observed_data)
        
        
        if (default_prior & all(is.na(prior))) {
          prior <- rep(1, n_levels)
        } else{
          if (is.character(prior)){
            prior <- dataset %>% dplyr::select(all_of(prior)) %>% dplyr::pull()
          } else if (is.array(prior)){
            prior <-  prior
          } else if (is.numeric(prior)){
            prior <-  prior
          } else{
            print("prior much a column of the input data or a vector")
          }
        }
        
        alphas <- prior
        counts <- observed_data
        thetas <- expected_data
        
        if(sum(thetas) != 1) {
          thetas <- thetas/sum(thetas)
          }
        
        expected <- setNames(sum(counts)*thetas, names(counts))
        
        lbeta.xa <- sum(lgamma(alphas + counts)) - lgamma(sum(alphas + counts))
        lbeta.a  <- sum(lgamma(alphas)) - lgamma(sum(alphas))
      
        if (any(rowSums(cbind(thetas, counts)) == 0)) {
          LogBF10 <- (lbeta.xa-lbeta.a)
        } else {
          LogBF10 <- (lbeta.xa-lbeta.a) + (0 - sum(counts * log(thetas))) 
        }
      
        BF <- data.frame(LogBF10 = LogBF10,
                         BF10    = exp(LogBF10),
                         BF01    = 1/exp(LogBF10))
      
        return(list(BF       = BF,
                    expected = expected))
        
      }
    
    Sim_Power_mult_calc <- function(seed = 12345, 
                                    sim_N = 5000,             # set to 5000 for real simulation
                                    sample_N = 1200,
                                    sim_prob = c(0.2, 0.2, 0.2, 0.2, 0.2), 
                                    nil_effect = c(0.2, 0.2, 0.2, 0.2, 0.2)){
      library(tidyverse)
      
      set.seed(seed)
    
      tmp_data <- data.frame(rmultinom(n=sim_N, size=sample_N, prob = sim_prob))
    
      test_BF <- data.frame(matrix(nrow = sim_N, ncol = 2))
      colnames(test_BF) <- c("Iter", "BF10")
      for (ii in seq(sim_N)){
          sim_data1 <- tmp_data[, ii]
          sim_data2 <- nil_effect * sample_N
          test_df <- data.frame(expected = sim_data2,
                                obs = sim_data1)%>%
            dplyr::mutate(ageBins = paste0('bin', seq(5)))
          
          tmp_BF <- BayesMultiNomial(test_df, 
                                     factor = 'ageBins', 
                                     observed = 'obs', 
                                     expected = 'expected')
          test_BF$Iter[ii] <- ii
          test_BF$`BF10`[ii] <- tmp_BF$BF$BF10
          
      }
      
      BF_power <- data.frame(matrix(nrow = 1, ncol = 5))
      colnames(BF_power) <- c("Prob", "Category", "Sample_Size", "BF_3", "BF_6")
      
      BF_power$Prob <- paste0(round(sim_prob, 3), collapse = ';')
      
      if (sum(sim_prob == nil_effect)==length(sim_prob)) {
        
        BF_power$Category <- "Evidence_for_Null"
        BF_power$Sample_Size <- sample_N
        BF_power$BF_3 <- sum(test_BF$BF10 <= 1/3)/sim_N 
        BF_power$BF_6 <- sum(test_BF$BF10 <= 1/ 6)/sim_N 
      } else {
        BF_power$Category <- "Evidence_for_Effect"
        BF_power$Sample_Size <- sample_N
        BF_power$BF_3 <- sum(test_BF$BF10 >= 3)/sim_N 
        BF_power$BF_6 <- sum(test_BF$BF10 >= 6)/sim_N 
      }
      return(BF_power)
    }
    ######################################################################################
    
    tmp_power <- Sim_Power_mult_calc(sim_prob = sim_probs[jj, 1:5],
                                     sim_N = sim_N,
                                     sample_N = sample_N,
                                     nil_effect = c(0.2, 0.2, 0.2, 0.2, 0.2))
    tmp_power$sim_alpha <- sim_alpha
    return(tmp_power)
  }
  
  # close the used thread
  stopCluster(cl)
  
  return(res_bf_power_mult)
}
```

```{r foreach main, warning=FALSE}
# Test the function "Sim_Power_mult" with 50 times, and alpha for Dirichlet distribution as a vector of 10s
startTime <- Sys.time()
test_mt <- Sim_Power_mult_mt(sim_N = 5000, sim_N_probs = 50, sim_alpha = 1)
endTime <- Sys.time()
print(endTime - startTime) 

# sim_N = 50 time = 11.21 sec
# sim_N = 500 time = 47.37 sec
# sim_N = 5000 time = 6.52 min
```

Our simulation found that, for age ratio, the current setting (prior and threshold of BF value as 3), the results revealed that for 93.8% of the probabilities generated by an “uniform” Dirichlet distribution, the current setting can provide evidence that the probability is different from null with in 80% of the case. 


We also simulated a case in which t-test (mean age difference) can not detect the difference of distribution but Bayesian multinomial test can. This simulation is to address reviewers' concern.
```{r comparing multinomial and t}

# generate data:
sim_prob1 <- c(0.05, 0.45, 0.35, 0.1, 0.05)
sim_prob2 <- c(0.45, 0.05, 0.1, 0.35, 0.05)

# N = 1200
#
n_iter <- 1000
sim_N1 <- data.frame(rmultinom(n=n_iter, size=1200, prob = sim_prob1))
sim_N2 <- data.frame(rmultinom(n=n_iter, size=1200, prob = sim_prob2))

# generate age data for t-test
set.seed(12345)
sim_df1 <- data.frame(matrix(nrow = 1200, ncol = n_iter))
sim_df2 <- data.frame(matrix(nrow = 1200, ncol = n_iter))
for (kk in (seq(ncol(sim_N1)))){ 
  tmp1 <-  round(runif(sim_N1[1, kk], min = 0, max = 17),0)
  tmp2 <-  round(runif(sim_N1[2, kk], min = 18, max = 25),0)
  tmp3 <-  round(runif(sim_N1[3, kk], min = 26, max = 40),0)
  tmp4 <-  round(runif(sim_N1[4, kk], min = 41, max = 59),0)
  tmp5 <-  round(runif(sim_N1[5, kk], min = 60, max = 100),0)
  
  tmp <- c(tmp1, tmp2, tmp3, tmp4, tmp5)
  sim_df1[, kk] <- tmp
}

for (kk in (seq(ncol(sim_N2)))){ 
  tmp1 <-  round(runif(sim_N2[1, kk], min = 0, max = 17),0)
  tmp2 <-  round(runif(sim_N2[2, kk], min = 18, max = 25),0)
  tmp3 <-  round(runif(sim_N2[3, kk], min = 26, max = 40),0)
  tmp4 <-  round(runif(sim_N2[4, kk], min = 41, max = 59),0)
  tmp5 <-  round(runif(sim_N2[5, kk], min = 60, max = 100),0)
  
  tmp <- c(tmp1, tmp2, tmp3, tmp4, tmp5)
  sim_df2[, kk] <- tmp
}

# t-test

rm('sim_TTest')
sim_TTest <- data.frame(matrix(nrow = n_iter, ncol = 3))
colnames(sim_TTest) <- c("t_value", "p_value", "sig")

for (kk in (seq(ncol(sim_N2)))){
  
  tmp_ttest <- t.test(sim_df1[,kk], sim_df2[,kk])
  sim_TTest$t_value[kk] <- tmp_ttest$statistic
  sim_TTest$p_value[kk] <- tmp_ttest$p.value
  if (tmp_ttest$p.value < 0.05) {
    sim_TTest$sig[kk] <- 1
  }else {
    sim_TTest$sig[kk] <- 0
  }
}

# power of ttest
mean(sim_TTest$sig)

## mutlinomial

rm('sim_MNtest')
sim_MNtest <- data.frame(matrix(nrow = n_iter, ncol = 2))
colnames(sim_MNtest) <- c("BF", "sig")

for (kk in (seq(ncol(sim_N1)))){
   tmp_df1 <- sim_N1[, kk]
   tmp_df2 <- sim_N2[, kk]
   
   test_df <- data.frame(expected = tmp_df1,
                         obs = tmp_df2)%>%
     dplyr::mutate(ageBins = paste0('bin', seq(5)))
      
   tmp_BF <- BayesMultiNomial(test_df, 
                                 factor = 'ageBins', 
                                 observed = 'obs', 
                                 expected = 'expected')
   sim_MNtest$BF[kk] <- tmp_BF$BF$BF10
    
  if (tmp_BF$BF$BF10 > 6) {
    sim_MNtest$sig[kk] <- 1
  }else {
    sim_MNtest$sig[kk] <- 0
  }
}

mean(sim_MNtest$sig)
```

# Load data and preprocess the data

Now we start the analysis of our example data

```{r Loading data, message=FALSE, warning=FALSE}
load("df_chinese_subj_rr_stage1.RData")
```

```{r disposal data, message=FALSE, warning=FALSE}

df_census6_age <- df_census6 %>% 
  dplyr::select(1,3,4) %>% 
  dplyr::rename(ageBins=1,
                male=2,
                female=3) %>% 
  dplyr::mutate_at(c("ageBins","male","female"),as.numeric) %>% 
  na.omit() %>% 
  dplyr::add_row(ageBins=100,
                 male=8852,
                 female=27082) %>%  ###100 represent 100 years old and above
  tidyr::pivot_longer(-ageBins,names_to = "sex",values_to = "num")
 
df_census7_age <- df_census7 %>% 
  dplyr::select(1,3,4) %>% 
  dplyr::rename(ageBins=1,
                male=2,
                female=3) %>% 
  dplyr::mutate_at(c("ageBins","male","female"),as.numeric) %>% 
  na.omit() %>% 
  dplyr::add_row(ageBins=100,
                 male=35129,
                 female=83737) %>% ###100 represent 100 years old and above
  tidyr::pivot_longer(-ageBins,names_to = "sex",values_to = "num")
  
```

# Test three hypotheses

## Test the 1st hypothesis
*This can only be done after collecting data.*

## Testing the 2nd hypothesis

Here we will test whether the sex ratio and age distribution from Chinese psychological studies are similar to that of the census data. As a comparison, we also compared that data from sociology, CFPS 2018, to the census data too. We use Bayesian multinomial test (Bayesian goodness-of-fit test) to examine whether the observed (Chinese psychological samples) fit the expected (7th Census data). 

$H_0$: $\theta = c$, where $c$ is defined by census data or CFPS 2018;
$H_1$: $\theta$ is free to vary.

### Sex distribution

```{r H2a sex, message=FALSE, warning=FALSE}
df_PSA001_sex_CN <- df_PSA001 %>%
  dplyr::filter(Countries == "CN") %>%
  dplyr::count(Sex) %>%
  dplyr::mutate(Proportion = round(n / sum(n), 2) * 100,
                Site = "PSA001",
                Sex = ifelse(Sex == "f", 'female', 'male' )) %>%
  dplyr::select(Site, Sex, Proportion)

df_census7_sex <- df_census7 %>%
  dplyr::select(c(6,7)) %>%        
  dplyr::slice(c(6)) %>%
  dplyr::rename(male=1, 
                female=2) %>%
  dplyr::mutate(Site = "Census7") %>%
  tidyr::pivot_longer(c(male, female), 
                      names_to = "Sex",
                      values_to = "Proportion") %>%
  dplyr::mutate(Proportion = round(as.numeric(Proportion), 0))

df_CFPS2018_sex <- df_CFPS2018 %>%
  dplyr::rename(Sex = QA002) %>%
  dplyr::count(Sex) %>%
  dplyr::filter(!is.na(Sex)) %>%
  dplyr::mutate(Proportion = round(n / sum(n), 2) * 100,
                Site = "CFPS2018",
                Sex = ifelse(Sex == 1, "male", "female")) %>%
  dplyr::select(Site, Sex, Proportion)

df_sex_ratio <- rbind(df_census7_sex, df_CFPS2018_sex, df_PSA001_sex_CN)

### get the data for Bayesian mutlinomial test as in JASP
df_sex_ratio_jasp <- df_sex_ratio %>%
  tidyr::pivot_wider(names_from = Site,
                     values_from = Proportion)
## save to csv
write.csv(df_sex_ratio_jasp, "df_sex_ratio_jasp.csv", row.names=FALSE)

BF_h2a_sex_psych <- BayesMultiNomial(dataset = df_sex_ratio_jasp, factor = "Sex", observed = "PSA001", expected = "Census7")
BF_h2a_sex_cfps <- BayesMultiNomial(dataset = df_sex_ratio_jasp, factor = "Sex", observed = "CFPS2018", expected = "Census7")

fig3a <- ggplot(df_sex_ratio, aes(Site, Proportion,fill=Sex)) +
  geom_col() +
  theme_classic()+
  xlab("Data sources") +
  theme(legend.position = "bottom",
        legend.key.size = unit(20,"pt"),
        legend.box.spacing = unit(4,"pt"),
        legend.title = element_blank(),
        axis.title = element_text(size = 16, family = "serif"),
        legend.text = element_text(size = 16, family = "serif"),
        axis.text = element_text(size =16, family = "serif"))
#fig3a
```

We found strong evidence for the $H_1$ that the sex ratio from PSA001 is different from that of Census data, with $Log(BF_{10})$ = `r BF_h2a_sex_psych$BF$LogBF10`. On the contrast, for the CFPS data, we found moderate evidence for the $H_0$ that sex ratio from CFPS2018 is not different from that of Census data, $Log(BF_{10})$ = `r BF_h2a_sex_cfps$BF$LogBF10`

### Age distribution

Here we will compare the age distribution of samples from psychological studies (PSA 001 as the example) and the Census data.

First, we define a function to segment the agebins of census.

```{r define a func for propotion of census age bins, message=FALSE, warning=FALSE}
Func_census_Age_Prop <- function(df_census, break_names, label_names,level_names,wider_form=TRUE){

  # function for calculating the proportion of age bins based on the break_names and label_names
  # df: the input data, with ageBins,male, female,and site
  # break_names, a vector of number
  # label_names, a vector of string
  # level_names, a factor
  #
  # return a wide-format data frame for further BF calculation
  
  df_tmp_census <- df_census %>%
    dplyr::mutate(ageBins=cut(ageBins,
                              breaks=break_names,
                              labels=label_names)) %>%
    group_by(ageBins,sex) %>% 
    summarise(num=sum(num)) %>% 
    ungroup() %>% 
    dplyr::mutate(freq=(num/sum(num))*100) %>% 
    dplyr::mutate(percent = floor(freq),
                  indx = freq - percent,
                  site="census7")
  
  df_tmp_census$ageBins= factor(df_tmp_census$ageBins,levels=level_names)

  ## below we fill the percentage to 100%
  
  filler_idx_census <- df_tmp_census %>%
    dplyr::group_by(site) %>% 
    dplyr::summarise(sum = sum(percent)) %>%
    dplyr::ungroup() 

  df_tmp_filled_census <- data.frame(matrix(ncol = ncol(df_tmp_census), nrow = 0))
  colnames(df_tmp_filled_census) <- colnames(df_tmp_census)

  for (ii in 1:nrow(filler_idx_census)){
    tmp_census <- df_tmp_census %>% 
      dplyr::filter(site == filler_idx_census$site[ii]) %>%
      dplyr::arrange(desc(indx))
    
    if (filler_idx_census$sum[ii] < 100) {
      for (jj in seq(100 - filler_idx_census$sum[ii])){
        tmp_census$percent[jj] <- tmp_census$percent[jj] + 1
      }
    }
    df_tmp_filled_census <- rbind(df_tmp_filled_census, tmp_census)
  }
  
  df_tmp_filled_census <- df_tmp_filled_census %>%
    dplyr::arrange(ageBins, sex)

  if (wider_form){
    df_tmp_filled_census <- df_tmp_filled_census %>%
      dplyr::select(-c(num, freq, indx)) %>%
      tidyr::pivot_wider(names_from = "ageBins", values_from = "percent") 
  }

  return(df_tmp_filled_census)
}
```

Next, we cotinue to defining a function to segment the agebins of pPSA001.

```{r define a func for proportion of PSA001 age bins, message=FALSE, warning=FALSE}
Func_PSA001_Age_Prop <- function(df_PSA, break_names, label_names, level_names,wider_form=TRUE){
  
  # function for calculating the proportion of age bins based on the break_names and label_names
  # df: the input data, with user_id, Countries, Sex, and Age
  # break_names, a vector of number
  # label_names, a vector of string
  # level_names, a factor
  #
  # return a wide-format data frame for further BF calculation
  
  df_tmp_PSA <- df_PSA %>%
    dplyr::select(user_id, Countries, Sex, Age) %>%
    dplyr::filter(Countries=="CN") %>% 
    dplyr::filter(!is.na(Age)) %>% 
    dplyr::mutate(ageBins_pyr=cut(Age, 
                              breaks=break_names,  
                              labels=label_names)) %>%
    dplyr::count(ageBins_pyr, Sex) %>%
    dplyr::mutate(freq = (n / sum(n))*100) %>%
    tidyr::complete(ageBins_pyr, Sex,fill = list(n = 0, freq = 0)) %>%
    dplyr::mutate(percent = floor(freq),
                  indx = freq - percent) %>% 
    dplyr::mutate(site="PSA001",
                  Sex=ifelse(Sex=="f","female_PSA","male_PSA"))
    
  
  df_tmp_PSA$ageBins_pyr= factor(df_tmp_PSA$ageBins_pyr,levels=level_names)
  
  ## below we fill the percentage to 100%
  
  filler_idx_PSA <- df_tmp_PSA %>%
    dplyr::group_by(site) %>%
    dplyr::summarise(sum = sum(percent)) %>%
    dplyr::ungroup() 

  df_tmp_filled_PSA <- data.frame(matrix(ncol = ncol(df_tmp_PSA), nrow = 0))
  colnames(df_tmp_filled_PSA) <- colnames(df_tmp_PSA)

  for (ii in 1:nrow(filler_idx_PSA)){
    tmp_PSA <- df_tmp_PSA %>% 
      dplyr::filter(site == filler_idx_PSA$site[ii]) %>%
      dplyr::arrange(desc(indx))
    
    if (filler_idx_PSA$sum[ii] < 100) {
      for (jj in seq(100 - filler_idx_PSA$sum[ii])){
       tmp_PSA$percent[jj] <- tmp_PSA$percent[jj] + 1
      }
    }
    df_tmp_filled_PSA <- rbind(df_tmp_filled_PSA, tmp_PSA)
  }
  df_tmp_filled_PSA <- df_tmp_filled_PSA %>%
    dplyr::arrange(ageBins_pyr,Sex)
  
  if (wider_form){
    df_tmp_filled_PSA <- df_tmp_filled_PSA %>%
      dplyr::select(-c(n, freq, indx)) %>%
      tidyr::pivot_wider(names_from = "ageBins_pyr", values_from = "percent") 
  }
  
  
  return(df_tmp_filled_PSA)
}
```

#### Age bins [set 1]: demogrphic age bins

```{r H2b ageBins plot, message=FALSE, warning=FALSE}
df_PSA001_Age_CN <- Func_PSA001_Age_Prop(df_PSA001,
                                         break_names =c(-Inf,4.5,9.5,14.5,19.5,24.5,
                                                        29.5,34.5,39.5,44.5,49.5,
                                                        54.5,59.5,64.5,69.5,74.5,
                                                        79.5,84.5,89.5,94.5,Inf),
                                         label_names = c("0~4","5~9","10~14","15~19","20~24",
                                     "25~29","30~34","35~39","40~44","45~49",
                                     "50~54","55~59","60~64","65~69","70~74",
                                     "75~79","80~84","85~89", "90~94",">=95"),
                                     level_names = c("0~4","5~9","10~14","15~19","20~24",
                                     "25~29","30~34","35~39","40~44","45~49",
                                     "50~54","55~59","60~64","65~69","70~74",
                                     "75~79","80~84","85~89", "90~94",">=95"),
                     wider_form = FALSE)
                                          
df_census7_age_new <- Func_census_Age_Prop(df_census7_age,
                     break_names = c(-Inf,4.5,9.5,14.5,19.5,24.5,
                                     29.5,34.5,39.5,44.5,49.5,
                                     54.5,59.5,64.5,69.5,74.5,
                                      79.5,84.5,89.5,94.5,Inf),
                     label_names = c("0~4","5~9","10~14","15~19","20~24",
                                     "25~29","30~34","35~39","40~44","45~49",
                                     "50~54","55~59","60~64","65~69","70~74",
                                     "75~79","80~84","85~89", "90~94",">=95"),
                     level_names = c("0~4","5~9","10~14","15~19","20~24",
                                     "25~29","30~34","35~39","40~44","45~49",
                                     "50~54","55~59","60~64","65~69","70~74",
                                     "75~79","80~84","85~89", "90~94",">=95"),
                     wider_form = FALSE)

fig3b <- ggplot(data= df_census7_age_new, aes(x=ageBins, y=ifelse(sex=="male", -percent, percent), fill=sex)) +
  geom_col(alpha=0.5, width = 1) +
  geom_line(data = df_PSA001_Age_CN, aes(x=ageBins_pyr,
                                      y = ifelse(Sex == "male_PSA", -percent/2.5, percent/2.5),
                                      group=Sex,color="PSA001"), size=1, inherit.aes = FALSE) +
  scale_y_continuous(limits = c(-15,15),sec.axis = sec_axis(~.*2.5, name = "Proportion (PSA001)")) +
  coord_flip() +
  labs(y="Proportion (census data)", x = "Age bins", color=NULL)+
  annotate("text",label= "italic(Male)",x=19,y=-2,parse=TRUE,size=8, family = "serif") +
  annotate("text",label= "italic(Female)",x=19,y=3,parse=TRUE,size=8,family = "serif") +
  scale_color_manual(values = c("red","blue"))+
  theme_classic()+
  theme(panel.border =element_rect(fill=NA,color="black"),
        legend.position ="bottom",
        legend.box.spacing = unit(2,"pt"),
        legend.text = element_text(size = 16, family = "serif"),
        legend.title = element_blank(),
        axis.title = element_text(size = 16,family = "serif"),
        axis.text = element_text(size = 16,family = "serif"))

fig3 <- fig3a + fig3b +  plot_annotation(tag_levels = 'A')
ggsave("fig3.pdf", fig3, device = "pdf", width=16, height = 9)

fig3
```

Also get the data for Bayesian multinomial test.

```{r test H2b using BMT, message=FALSE, warning=FALSE}
### PAS001' age is divided into ten years
df_PSA001_Age_CN_jasp_interval10 <- Func_PSA001_Age_Prop(df_PSA001,
                                                          break_names = c(0, 9.5, 19.5, 29.5, 30.5, 40.5, 59.5, Inf),
                                                          label_names = c("0~9","10~19","20~29", "30~39", "40~49", "50~59", ">=60"),
                                                          level_names = c("0~9","10~19","20~29", "30~39", "40~49", "50~59", ">=60"),
                                                          wider_form = FALSE) %>% 
  dplyr::group_by(ageBins_pyr) %>% 
  dplyr::summarise(percent=sum(percent)) %>%
  dplyr::ungroup() %>% 
  dplyr::rename(PSA001_CN=percent,
                ageBins=ageBins_pyr)


### PSA001' age is divided into stages of development
df_PSA001_Age_CN_Jasp_interval_stages <- Func_PSA001_Age_Prop(df_PSA001,
                                                              break_names = c(0, 17.5, 25.5, 40.5, 59.5, Inf),
                                                              label_names = c("0~17","18~25","26~40", "41~59", ">=60"),
                                                              level_names = c("0~17","18~25","26~40", "41~59", ">=60"),
                                                              wider_form = FALSE) %>%
  dplyr::group_by(ageBins_pyr) %>% 
  dplyr::summarise(percent=sum(percent)) %>%
  dplyr::ungroup() %>% 
  dplyr::rename(PSA001_CN=percent,
                ageBins=ageBins_pyr)
  

###Census7' age is divided into ten years
df_census7_age_jasp_interval10 <- Func_census_Age_Prop(df_census7_age,
                                                       break_names = c(-Inf, 9.5, 19.5, 29.5, 30.5, 40.5, 59.5, Inf),
                                                       label_names = c("0~9","10~19","20~29", "30~39", "40~49", "50~59", ">=60"),
                                                       level_names = c("0~9","10~19","20~29", "30~39", "40~49", "50~59", ">=60"),
                                                       wider_form = FALSE) %>% 
  dplyr::group_by(ageBins) %>% 
  dplyr::summarise(percent=sum(percent)) %>%
  dplyr::ungroup() %>% 
  dplyr::rename(Census7=percent)


###Census' age is divided into the stages of development
df_census7_age_jasp_interval_stages <- Func_census_Age_Prop(df_census7_age,
                                                       break_names = c(-Inf, 17.5, 25.5, 40.5, 59.5, Inf),
                                                       label_names = c("0~17","18~25","26~40", "41~59", ">=60"),
                                                       level_names = c("0~17","18~25","26~40", "41~59", ">=60"),
                                                       wider_form = FALSE) %>% 
  dplyr::group_by(ageBins) %>% 
  dplyr::summarise(percent=sum(percent)) %>%
  dplyr::ungroup() %>% 
  dplyr::rename(Census7=percent)


df_age_jasp_interval10 <- df_PSA001_Age_CN_jasp_interval10 %>% 
  dplyr::left_join(.,df_census7_age_jasp_interval10)

df_age_jasp_interval_stages <- df_PSA001_Age_CN_Jasp_interval_stages %>% 
  dplyr::left_join(.,df_census7_age_jasp_interval_stages)


# save the CSV to compare the BayesMultiNomial with the result in JASP
write.csv(df_age_jasp_interval_stages, "df_age_jasp_interval_stages.csv", row.names = FALSE)

write.csv(df_age_jasp_interval10, "df_age_jasp_interval10.csv", row.names = FALSE)

BF_h2b_age_psych_interval10 <- BayesMultiNomial(dataset = df_age_jasp_interval10, 
                                     factor = "ageBins", 
                                     observed = "PSA001_CN",
                                     expected = "Census7")

BF_h2b_age_psych_interval_stages <- BayesMultiNomial(dataset = df_age_jasp_interval_stages,
                                                     factor = "ageBins",
                                                     observed = "PSA001_CN",
                                                     expected = "Census7")
```

When we divide the age into 10 years,we found strong evidence for the $H_2$ that the age distribution from PSA001 is different from that of Census data, with $Log(BF_{10})$ = `r BF_h2b_age_psych_interval10$BF$LogBF10`.

When we divide age into stages of psychological development, we found strong evidence for the $H_2$ that the age distribution from PSA001 is different from that of Census data, with $Log(BF_{10})$ = `r BF_h2b_age_psych_interval_stages$BF$LogBF10`.

#### Age bins [set 2]: Psychological age bins

## Test H3: Chinese samples versus samples from other countries

We first select data for plotting.

```{r preproc data, message=FALSE, warning=FALSE}
### Get countries with n >=30
PSA001_valid_countries <-  df_PSA001 %>%
  dplyr::group_by(Countries) %>%
  dplyr::summarise(n = n()) %>%
  dplyr::ungroup() %>%
  dplyr::filter(n >=30 & !is.na(Countries)) %>%
  dplyr::pull(Countries)

### remove data without sex info
df_PSA001_valid_sex <-  df_PSA001 %>% 
  dplyr::filter(Countries %in% PSA001_valid_countries) %>%
  dplyr::mutate(Sex = ifelse(Sex == "no" | Sex == "na", NA, Sex))


df_PSA001_valid_merge <- merge(df_PSA001_valid_sex, df_regionCode, by.x = "Countries", by.y = "country_iso2")

df_PSA001_valid_merge_sex_ratio <- df_PSA001_valid_merge %>%
  dplyr::filter(!is.na(Sex)) %>%
  dplyr::count(weird, Countries, Sex) %>%
  dplyr::group_by(weird, Countries) %>%
  dplyr::mutate(Proportion = round(n / sum(n), 2)) %>%
  dplyr::arrange(Sex, Proportion) %>%
  dplyr::ungroup()

countries_order_sex <- df_PSA001_valid_merge_sex_ratio %>%
  dplyr::filter(Sex == "f") %>%
  dplyr::pull(Countries)

df_PSA001_valid_merge_sex_ratio_sorted <- df_PSA001_valid_merge_sex_ratio %>%
  dplyr::mutate(Countries = factor(Countries, levels = countries_order_sex))

df_PSA001_valid_merge_sex_ratio_sorted_wide <- df_PSA001_valid_merge_sex_ratio_sorted %>%
  dplyr::select(-c(weird,n)) %>%
  dplyr::mutate(Proportion = Proportion * 100)  %>%
  tidyr::pivot_wider(names_from = "Countries", values_from = "Proportion")
```

Then, we define a function for calculating BF for multiple countries.

```{r define a function for calculating BF for multiple countries, message=FALSE, warning=FALSE}
# create a new variable to store the BF values
Func_BFpairs <- function(df, countries_order, prop_name){
  
  # create a temp variable for storing 
  BF_mult_tmp <- data.frame(matrix(nrow = 0, ncol = 5))
  colnames(BF_mult_tmp) <- c("Observed", "Expected", "Log(BF10)_NonInform", "BF10_NonInform", "BF01_NonInform")
  
  for (ii in seq(length(countries_order))){
    country <- countries_order[ii]
    if (country != "CN"){
      df_tmp <- df %>% dplyr::select(prop_name, one_of(country), "CN")
      
      BF_tmp <- BayesMultiNomial(dataset = df_tmp, 
                                 factor = prop_name, observed = country, expected = "CN")
      
      BF_mult_tmp[ii,] <- c(country, "CN", BF_tmp$BF$LogBF10, BF_tmp$BF$BF10, BF_tmp$BF$BF01)
    } 
  }
  
  countries_order_age <- BF_mult_tmp %>% 
    tidyr::drop_na() %>%
    dplyr::mutate(`Log(BF10)_NonInform` = as.numeric(`Log(BF10)_NonInform`)) %>%
    dplyr::arrange(`Log(BF10)_NonInform`) %>%
    dplyr::pull(Observed)
  
  BF_mult_p_tmp <- BF_mult_tmp %>%
    tidyr::drop_na() %>%
    dplyr::select(1,2,3) %>%
    dplyr::mutate(Contries = factor(Observed, levels = countries_order_age),
                  `Log(BF10)_NonInform` = as.numeric(`Log(BF10)_NonInform`)) 
  
  return(BF_mult_p_tmp)
}
```

Then,we calculating BF and plotting figure 4a.

```{r Test H3a, message=FALSE, warning=FALSE}
# compare each country with CN, non-informative prior
BF_h3a_sex_p <- Func_BFpairs(df = df_PSA001_valid_merge_sex_ratio_sorted_wide,
                             countries_order = countries_order_sex,
                             prop_name = "Sex")

fig4a <- ggplot(BF_h3a_sex_p, aes( x = `Log(BF10)_NonInform`, y = Contries)) +
  geom_point() +
  scale_color_grey() +
  xlim(-3, 21) +
  scale_y_discrete(limits=rev) +
  geom_vline(xintercept = c(log(1/10), log(1/6), 0, log(6), log(10)), 
             colour = c("red", "tomato", "black", "deepskyblue","blue"), 
             linetype=c("longdash", "longdash", "solid", "longdash","longdash")) + 
  geom_text(aes(x=log(10), label="\nStrong evidence for H1", y = 23), colour="blue", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(6), label="Moderate evidence for H1\n", y = 23), colour="deepskyblue", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(1/6), label="\nModerate evidence for H0", y = 23), colour="tomato", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(1/10), label="Strong evidence for H0\n", y = 23), colour="red", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  ggtitle("Sex ratio") + 
  xlab("Log(BF10)")+
  theme_bw() +
        theme(panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.background = element_blank(),
              panel.border = element_blank(),
              text = element_text(family='Times'),
              axis.text.x = element_text (size = 14, color = 'black',  hjust = 1),
              axis.text.y = element_text (size = 16, color = 'black'),
              plot.title = element_text(lineheight=.8, face="bold", size = 18, margin=margin(0,0,20,0)),
              axis.text = element_text (size = 16, color = 'black'),
              axis.title = element_text (size = 16),
              axis.title.x = element_text (size = 16),
              axis.title.y = element_text( size = 16),
              axis.line.x = element_line(color='black', size = 1),
              axis.line.y = element_line(color='black', size = 1))
#fig4a
```

Plotting figure 4c.

```{r figure 4c, message=FALSE, warning=FALSE}
fig4c <- ggplot(df_PSA001_valid_merge_sex_ratio_sorted, aes(x=Proportion, y=Countries,fill=Sex)) +
  geom_col(alpha = .75)+
  labs(y="Countries") + 
  scale_fill_discrete(label=c("female","male")) +
  theme_classic()+
  guides(y="axis_nested") +
  theme(legend.title = element_text(size = 15,family = "serif"),
        axis.title= element_text(size = 15,family = "serif"),
        axis.text = element_text(size = 10,family = "serif"),
        strip.text = element_text(size = 15,family = "serif"),
        strip.background = element_rect(fill = NA,color = NA),
        panel.border = element_rect(fill = NA,color = "black")) +
  scale_x_continuous(breaks = seq(0, 1, by = 0.1)) +
  facet_wrap(~ weird, scales = "free")
#fig4c
```

Get the percentage of each age bin and save for Bayesian multinomial test. We found that if the expected proportion contains zero if may cause problem in the calculation, thus, we re-organized the data based on the proportion data of Chinese sample.

```{r define a func for proportion of age bins, message=FALSE, warning=FALSE}
Func_Age_Prop <- function(df, break_names, label_names, wider_form=TRUE){
  
  # function for calculating the proportion of age bins based on the break_names and label_names
  # df: the input data, with user_id, Countries, Sex, and Age
  # break_names, a vector of number
  # label_names, a vector of string
  #
  # return a wide-format data frame for further BF calculation
  
  df_tmp <- df %>%
    dplyr::select(user_id, Countries, Sex, Age) %>%
    dplyr::mutate(ageBins=cut(Age, 
                              breaks=break_names,  
                              labels=label_names)) %>%
    dplyr::count(Countries, ageBins) %>%
    dplyr::group_by(Countries) %>%
    dplyr::mutate(freq = (n / sum(n))*100) %>%
    dplyr::ungroup() %>%
    tidyr::complete(Countries, ageBins, fill = list(n = 0, freq = 0)) %>%
    dplyr::mutate(percent = floor(freq),
                  indx = freq - percent)
  
  ## below we fill the percentage to 100%
  
  filler_idx <- df_tmp %>%
    dplyr::group_by(Countries) %>%
    dplyr::summarise(sum = sum(percent)) %>%
    dplyr::ungroup() 

  df_tmp_filled <- data.frame(matrix(ncol = ncol(df_tmp), nrow = 0))
  colnames(df_tmp_filled) <- colnames(df_tmp)

  for (ii in 1:nrow(filler_idx)){
    tmp <- df_tmp %>% 
      dplyr::filter(Countries == filler_idx$Countries[ii]) %>%
      dplyr::arrange(desc(indx))
    
    if (filler_idx$sum[ii] < 100) {
      for (jj in seq(100 - filler_idx$sum[ii])){
       tmp$percent[jj] <- tmp$percent[jj] + 1
      }
    }
    df_tmp_filled <- rbind(df_tmp_filled, tmp)
  }
  df_tmp_filled <- df_tmp_filled %>%
    dplyr::arrange(Countries, ageBins)
  
  if (wider_form){
    df_tmp_filled <- df_tmp_filled %>%
      dplyr::select(-c(n, freq, indx)) %>%
      tidyr::pivot_wider(names_from = "Countries", values_from = "percent") 
  }
  
  
  return(df_tmp_filled)
}
```

Process the age data of PSA001 for plotting figure 4d.

```{r prepare data for test, message=FALSE, warning=FALSE}
df_PSA001_Age_valid <- df_PSA001 %>% 
  dplyr::filter(!is.na(Age)) %>%   
  dplyr::filter(Countries %in% PSA001_valid_countries) 

# merge with country code and force the age over 60 in a narrow range for visualization
df_PSA001_Age_valid_countryCode <- merge(df_PSA001_Age_valid, df_regionCode, by.x = "Countries", by.y = "country_iso2") %>%
  dplyr::mutate(Age = ifelse(Age > 60, sample(c(61, 62, 63, 64, 65), 1), Age))

PSA001_valid_countries_sorted <- df_PSA001_Age_valid_countryCode %>%
  dplyr::group_by(Countries) %>%
  dplyr::summarise(medianAge = median(Age)) %>%
  dplyr::ungroup() %>%
  dplyr::arrange(medianAge) %>%
  dplyr::pull(Countries)

df_PSA001_Age_valid_countryCode_sorted <- df_PSA001_Age_valid_countryCode %>%
  dplyr::mutate(Countries = factor(Countries, levels = PSA001_valid_countries_sorted)) %>%
  dplyr::filter(!(Sex=="no" | Sex=="na"))

# age bin same as census data
df_PSA001_age_Jasp1 <- Func_Age_Prop(df = df_PSA001_Age_valid_countryCode_sorted,
                                     break_names = c(0, 10.5, 20.5, 30.5, 40.5, 50.5, 60.5, Inf),
                                     label_names = c("0~10","11~20","21~30", "31~40", "41~50", "51~60", ">=61"))

df_PSA001_age_Jasp1 <- df_PSA001_age_Jasp1 %>%
  # fill zero
  dplyr::mutate(CN = ifelse(CN==0, 1,
                            ifelse(CN==38, 37, 
                                   ifelse(CN  == 55, 54, CN))))

# age bin based on psychological aging stage
df_PSA001_age_Jasp2 <- Func_Age_Prop(df = df_PSA001_Age_valid_countryCode_sorted,
                                     break_names = c(0, 17.5, 25.5, 39.5, 59.5, Inf),
                                     label_names = c("0~17","18~25", "26~40", "41~59", ">=60"))

df_PSA001_age_Jasp2 <- df_PSA001_age_Jasp2 %>%
  # fill zero
  dplyr::mutate(CN = ifelse(CN==0, 1, 
                            ifelse(CN==80, 78, CN)))

df_PSA001_age_Jasp2_long <- Func_Age_Prop(df = df_PSA001_Age_valid_countryCode_sorted,
                                     break_names = c(0, 17.5, 25.5, 39.5, 59.5, Inf),
                                     label_names = c("0~17","18~25", "26~40", "41~59", ">=60"),
                                     wider_form = FALSE) %>%
  dplyr::left_join(., df_regionCode, by = c("Countries" = "country_iso2")) %>%
  dplyr::mutate(Proportion = percent/100)

# Countries order for plotting age bins proportions
df_PSA001_age_Jasp2_long_countries <- df_PSA001_age_Jasp2_long %>%
  dplyr::filter(ageBins == "18~25") %>%
  dplyr::arrange(Proportion) %>%
  dplyr::pull(Countries)

df_PSA001_age_Jasp2_long <- df_PSA001_age_Jasp2_long %>%
  dplyr::mutate(Countries = factor(Countries, levels = df_PSA001_age_Jasp2_long_countries))

```

Plotting figure 4d.

```{r preproc for age, message=FALSE, warning=FALSE}
fig4d <- ggplot(df_PSA001_age_Jasp2_long, aes(x=Proportion, y=Countries, fill=ageBins)) +
  geom_col(alpha = .75)+
  labs(y="Countries") + 
  scale_fill_discrete(label=c("0~17", "18~25", "26~40", "41~59",">=60" )) +
  theme_classic()+
  guides(y="axis_nested") +
  theme(legend.title = element_text(size = 15,family = "serif"),
        axis.title= element_text(size = 15,family = "serif"),
        axis.text = element_text(size = 10,family = "serif"),
        strip.text = element_text(size = 15,family = "serif"),
        strip.background = element_rect(fill = NA,color = NA),
        panel.border = element_rect(fill = NA,color = "black")) +
  scale_x_continuous(breaks = seq(0, 1, by = 0.1)) +
  facet_wrap(~ weird, scales = "free")
#fig4d
```

Plotting figure 4b.

```{r Test H3b,message=FALSE, warning=FALSE}
# BF for age bins 0, NA for informed prior because of zeros in the dataframe
BF_h3b_age_p_1 <- Func_BFpairs(df = df_PSA001_age_Jasp1, 
                             countries_order = countries_order_sex,
                             prop_name = "ageBins")

# BF for age bins 2
BF_h3b_age_p_2 <- Func_BFpairs(df = df_PSA001_age_Jasp2, 
                             countries_order = countries_order_sex,
                             prop_name = "ageBins")

fig4b <- ggplot(BF_h3b_age_p_2, aes( x = `Log(BF10)_NonInform`, y = Contries)) +
  geom_point() +
  scale_color_grey() +
  xlim(-10, 60) +
  scale_y_discrete(limits=rev) +
  geom_vline(xintercept = c(log(1/10), log(1/6), 0, log(6), log(10)), 
             colour = c("red", "tomato", "black", "deepskyblue","blue"), 
             linetype=c("longdash", "longdash", "solid", "longdash","longdash")) + 
  geom_text(aes(x=log(10), label="\nStrong evidence for H1", y = 23), colour="blue", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(6), label="Moderate evidence for H1\n", y = 23), colour="deepskyblue", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(1/6), label="\nModerate evidence for H0", y = 23), colour="tomato", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(1/10), label="Strong evidence for H0\n", y = 23), colour="red", alpha = 0.7, 
            angle=90, text=element_text(size=10))  +
  ggtitle("Age distribution") +
  xlab("Log(BF10)")+
  theme_bw() +
        theme(panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.background = element_blank(),
              panel.border = element_blank(),
              text = element_text(family='Times'),
              axis.text.x = element_text (size = 14, color = 'black',  hjust = 1),
              axis.text.y = element_text (size = 16, color = 'black'),
              plot.title = element_text(lineheight=.8, face="bold", size = 18, margin=margin(0,0,20,0)),
              axis.text = element_text (size = 16, color = 'black'),
              axis.title = element_text (size = 16),
              axis.title.x = element_text (size = 16),
              axis.title.y = element_text( size = 16),
              axis.line.x = element_line(color='black', size = 1),    
              axis.line.y = element_line(color='black', size = 1))
#fig4b
p_BF <- (fig4a + fig4b) /
   (fig4c + fig4d) +
  plot_annotation(tag_levels = 'A')  & 
  theme(plot.tag = element_text(size = 18, face = "bold"))

ggsave("Fig4_withBF.pdf", p_BF, device = "pdf", width=18, height = 18)
p_BF
```

Processing the age data of PSA001 and Plotting the figure S1a and S1b of the supplementary files.

```{r Plot using age groups similar to the age bins of census. See supplementary materials for this section, message=FALSE, warning=FALSE}

df_PSA001_age_Jasp1_long <- Func_Age_Prop(df = df_PSA001_Age_valid_countryCode_sorted,
                                     break_names = c(0, 10.5, 20.5, 30.5, 40.5, 50.5, 60.5, Inf),
                                     label_names = c("0~10","11~20","21~30", "31~40", "41~50", "51~60", ">=61"),
                                     wider_form = FALSE) %>%
  dplyr::left_join(., df_regionCode, by = c("Countries" = "country_iso2")) %>%
  dplyr::mutate(Proportion = percent/100)

# Countries order for ploting age bins proprotions
df_PSA001_age_Jasp1_long_countries <- df_PSA001_age_Jasp1_long %>%
  dplyr::filter(ageBins == "0~10") %>%
  dplyr::arrange(Proportion) %>%
  dplyr::pull(Countries)

df_PSA001_age_Jasp1_long <- df_PSA001_age_Jasp1_long %>%
  dplyr::mutate(Countries = factor(Countries, levels = df_PSA001_age_Jasp1_long_countries))


S1b <- ggplot(df_PSA001_age_Jasp1_long, aes(x=Proportion, y=Countries, fill=ageBins)) +
  geom_col(alpha = .75)+
  labs(y="Countries") + 
  scale_fill_discrete(label=c("0~10","11~20","21~30", "31~40", "41~50", "51~60", ">=61")) +
  theme_classic()+
  guides(y="axis_nested") +
  theme(legend.title = element_text(size = 15,family = "serif"),
        axis.title= element_text(size = 15,family = "serif"),
        axis.text = element_text(size = 10,family = "serif"),
        strip.text = element_text(size = 15,family = "serif"),
        strip.background = element_rect(fill = NA,color = NA),
        panel.border = element_rect(fill = NA,color = "black")) +
  scale_x_continuous(breaks = seq(0, 1, by = 0.1)) +
  facet_wrap(~ weird, scales = "free")
#S1b

S1a <- ggplot(BF_h3b_age_p_1, aes( x = `Log(BF10)_NonInform`, y = Contries)) +
  geom_point() +
  scale_color_grey() +
  xlim(-15, 60) +
  scale_y_discrete(limits=rev) +
  geom_vline(xintercept = c(log(1/10), log(1/6), 0, log(6), log(10)), 
             colour = c("red", "tomato", "black", "deepskyblue","blue"), 
             linetype=c("longdash", "longdash", "solid", "longdash","longdash")) + 
  geom_text(aes(x=log(10), label="\nStrong evidence for H1", y = 23), colour="blue", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(6), label="Moderate evidence for H1\n", y = 23), colour="deepskyblue", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(1/6), label="\nModerate evidence for H0", y = 23), colour="tomato", alpha = 0.7, 
            angle=90, text=element_text(size=10)) +
  geom_text(aes(x=log(1/10), label="Strong evidence for H0\n", y = 23), colour="red", alpha = 0.7, 
            angle=90, text=element_text(size=10))  +
  ggtitle("Age distribution") +
  xlab("Log(BF10)")+
  theme_bw() +
        theme(panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.background = element_blank(),
              panel.border = element_blank(),
              text = element_text(family='Times'),
              axis.text.x = element_text (size = 14, color = 'black',  hjust = 1),
              axis.text.y = element_text (size = 16, color = 'black'),
              plot.title = element_text(lineheight=.8, face="bold", size = 18, margin=margin(0,0,20,0)),
              axis.text = element_text (size = 16, color = 'black'),
              axis.title = element_text (size = 16),
              axis.title.x = element_text (size = 16),
              axis.title.y = element_text( size = 16),
              axis.line.x = element_line(color='black', size = 1),    
              axis.line.y = element_line(color='black', size = 1))
#S1a
p_BF_supp <- S1a + S1b +
  plot_layout(tag_level = 'new') +
  plot_annotation(tag_levels =list(c("S1a","S1b")))  & 
  theme(plot.tag = element_text(size = 18, face = "bold"))

ggsave("Fig4_withBF_supp.pdf", p_BF_supp, device = "pdf", width=18, height = 9)
p_BF_supp
```
